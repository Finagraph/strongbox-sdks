/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.14.7.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming



/** Models an account listed in a Chart Of Accounts. */
export class Account implements IAccount {
    /** A set of classifications for the account used for financial analysis. */
    classification!: AccountClassification[];
    /** A description of the account. */
    description?: string | undefined;
    /** An identifier for the account, unique within the scope of the Chart Of Accounts associated with this account. */
    id!: string;
    kind!: AccountKind;
    /** A friendly name for the account. */
    name!: string;
    role!: ChartOfAccountsRole;
    /** A hierarchical representation of any sub-accounts that are associated with this account. Sub-accounts are used to organize the Chart of Accounts for reporting purposes and may manifest themselves as subtotals in the presentaton of Financial Statements. */
    subaccounts!: Account[];
    /** A human-friendly alpha-numeric code or number as originally assigned to the account by the bookkeeper. If provided, this value may be helpful for classification, sorting, or as a secondary identifier for the account. */
    userAssignedCode?: string | undefined;
    /** The date on which the account was created, if known. This date is serialized to a string using the "YYYY-MM-DD" format as defined by ISO 8601-1:2019. */
    creationDate?: string | undefined;
    /** The date on which the account was last modified, if known. This date is serialized to a string using the "YYYY-MM-DD" format as defined by ISO 8601-1:2019. */
    lastModifiedDate?: string | undefined;

    constructor(data?: IAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.classification = [];
            this.subaccounts = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["classification"])) {
                this.classification = [] as any;
                for (let item of _data["classification"])
                    this.classification!.push(AccountClassification.fromJS(item));
            }
            this.description = _data["description"];
            this.id = _data["id"];
            this.kind = _data["kind"];
            this.name = _data["name"];
            this.role = _data["role"];
            if (Array.isArray(_data["subaccounts"])) {
                this.subaccounts = [] as any;
                for (let item of _data["subaccounts"])
                    this.subaccounts!.push(Account.fromJS(item));
            }
            this.userAssignedCode = _data["userAssignedCode"];
            this.creationDate = _data["creationDate"];
            this.lastModifiedDate = _data["lastModifiedDate"];
        }
    }

    static fromJS(data: any): Account {
        data = typeof data === 'object' ? data : {};
        let result = new Account();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.classification)) {
            data["classification"] = [];
            for (let item of this.classification)
                data["classification"].push(item.toJSON());
        }
        data["description"] = this.description;
        data["id"] = this.id;
        data["kind"] = this.kind;
        data["name"] = this.name;
        data["role"] = this.role;
        if (Array.isArray(this.subaccounts)) {
            data["subaccounts"] = [];
            for (let item of this.subaccounts)
                data["subaccounts"].push(item.toJSON());
        }
        data["userAssignedCode"] = this.userAssignedCode;
        data["creationDate"] = this.creationDate;
        data["lastModifiedDate"] = this.lastModifiedDate;
        return data; 
    }

    clone(): Account {
        const json = this.toJSON();
        let result = new Account();
        result.init(json);
        return result;
    }
}

/** Models an account listed in a Chart Of Accounts. */
export interface IAccount {
    /** A set of classifications for the account used for financial analysis. */
    classification: AccountClassification[];
    /** A description of the account. */
    description?: string | undefined;
    /** An identifier for the account, unique within the scope of the Chart Of Accounts associated with this account. */
    id: string;
    kind: AccountKind;
    /** A friendly name for the account. */
    name: string;
    role: ChartOfAccountsRole;
    /** A hierarchical representation of any sub-accounts that are associated with this account. Sub-accounts are used to organize the Chart of Accounts for reporting purposes and may manifest themselves as subtotals in the presentaton of Financial Statements. */
    subaccounts: Account[];
    /** A human-friendly alpha-numeric code or number as originally assigned to the account by the bookkeeper. If provided, this value may be helpful for classification, sorting, or as a secondary identifier for the account. */
    userAssignedCode?: string | undefined;
    /** The date on which the account was created, if known. This date is serialized to a string using the "YYYY-MM-DD" format as defined by ISO 8601-1:2019. */
    creationDate?: string | undefined;
    /** The date on which the account was last modified, if known. This date is serialized to a string using the "YYYY-MM-DD" format as defined by ISO 8601-1:2019. */
    lastModifiedDate?: string | undefined;
}

/** Models a classification for an account. */
export class AccountClassification implements IAccountClassification {
    /** An identifier for the account classification within the scope of the associated taxonomy. */
    classificationId!: string;
    /** The taxonomy in which the account classification is defined. */
    taxonomyId!: string;

    constructor(data?: IAccountClassification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classificationId = _data["classificationId"];
            this.taxonomyId = _data["taxonomyId"];
        }
    }

    static fromJS(data: any): AccountClassification {
        data = typeof data === 'object' ? data : {};
        let result = new AccountClassification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classificationId"] = this.classificationId;
        data["taxonomyId"] = this.taxonomyId;
        return data; 
    }

    clone(): AccountClassification {
        const json = this.toJSON();
        let result = new AccountClassification();
        result.init(json);
        return result;
    }
}

/** Models a classification for an account. */
export interface IAccountClassification {
    /** An identifier for the account classification within the scope of the associated taxonomy. */
    classificationId: string;
    /** The taxonomy in which the account classification is defined. */
    taxonomyId: string;
}

/** Models options for importing accounting data. */
export class AccountingDataImportParameters implements IAccountingDataImportParameters {
    /** Used to specify privacy controls to be applied to the imported financial data. The default if not specified is no privacy controls enabled. */
    privacyControls?: PrivacyControl[] | undefined;
    transactions?: TransactionImportOptions;
    financialStatements?: FinancialStatementImportOptions;
    receivables?: ReceivablesAndPayablesOptions;
    payables?: ReceivablesAndPayablesOptions;

    constructor(data?: IAccountingDataImportParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["privacyControls"])) {
                this.privacyControls = [] as any;
                for (let item of _data["privacyControls"])
                    this.privacyControls!.push(item);
            }
            this.transactions = _data["transactions"] ? TransactionImportOptions.fromJS(_data["transactions"]) : <any>undefined;
            this.financialStatements = _data["financialStatements"] ? FinancialStatementImportOptions.fromJS(_data["financialStatements"]) : <any>undefined;
            this.receivables = _data["receivables"] ? ReceivablesAndPayablesOptions.fromJS(_data["receivables"]) : <any>undefined;
            this.payables = _data["payables"] ? ReceivablesAndPayablesOptions.fromJS(_data["payables"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AccountingDataImportParameters {
        data = typeof data === 'object' ? data : {};
        let result = new AccountingDataImportParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.privacyControls)) {
            data["privacyControls"] = [];
            for (let item of this.privacyControls)
                data["privacyControls"].push(item);
        }
        data["transactions"] = this.transactions ? this.transactions.toJSON() : <any>undefined;
        data["financialStatements"] = this.financialStatements ? this.financialStatements.toJSON() : <any>undefined;
        data["receivables"] = this.receivables ? this.receivables.toJSON() : <any>undefined;
        data["payables"] = this.payables ? this.payables.toJSON() : <any>undefined;
        return data; 
    }

    clone(): AccountingDataImportParameters {
        const json = this.toJSON();
        let result = new AccountingDataImportParameters();
        result.init(json);
        return result;
    }
}

/** Models options for importing accounting data. */
export interface IAccountingDataImportParameters {
    /** Used to specify privacy controls to be applied to the imported financial data. The default if not specified is no privacy controls enabled. */
    privacyControls?: PrivacyControl[] | undefined;
    transactions?: TransactionImportOptions;
    financialStatements?: FinancialStatementImportOptions;
    receivables?: ReceivablesAndPayablesOptions;
    payables?: ReceivablesAndPayablesOptions;
}

/** Models the organization for which accounting and other financial data was prepared. */
export class AccountingEntity implements IAccountingEntity {
    baseCurrency?: Currency;
    fiscalYearEnd?: YearEnd;
    homeCountry?: Country;
    taxYearEnd?: YearEnd;
    /** A list of addresses. */
    addresses!: Address[];
    /** A list of emails. */
    emails!: EmailAddress[];
    /** A list of identifiers. */
    identifiers!: Identifier[];
    /** A list of names. */
    names!: OrganizationName[];
    /** A list of other contact methods. */
    otherContactMethods!: OtherContactMethod[];
    /** A list of phone numbers. */
    phoneNumbers!: PhoneNumber[];
    /** A list of websites. */
    websites!: Website[];

    constructor(data?: IAccountingEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.addresses = [];
            this.emails = [];
            this.identifiers = [];
            this.names = [];
            this.otherContactMethods = [];
            this.phoneNumbers = [];
            this.websites = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baseCurrency = _data["baseCurrency"] ? Currency.fromJS(_data["baseCurrency"]) : <any>undefined;
            this.fiscalYearEnd = _data["fiscalYearEnd"] ? YearEnd.fromJS(_data["fiscalYearEnd"]) : <any>undefined;
            this.homeCountry = _data["homeCountry"] ? Country.fromJS(_data["homeCountry"]) : <any>undefined;
            this.taxYearEnd = _data["taxYearEnd"] ? YearEnd.fromJS(_data["taxYearEnd"]) : <any>undefined;
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(Address.fromJS(item));
            }
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(EmailAddress.fromJS(item));
            }
            if (Array.isArray(_data["identifiers"])) {
                this.identifiers = [] as any;
                for (let item of _data["identifiers"])
                    this.identifiers!.push(Identifier.fromJS(item));
            }
            if (Array.isArray(_data["names"])) {
                this.names = [] as any;
                for (let item of _data["names"])
                    this.names!.push(OrganizationName.fromJS(item));
            }
            if (Array.isArray(_data["otherContactMethods"])) {
                this.otherContactMethods = [] as any;
                for (let item of _data["otherContactMethods"])
                    this.otherContactMethods!.push(OtherContactMethod.fromJS(item));
            }
            if (Array.isArray(_data["phoneNumbers"])) {
                this.phoneNumbers = [] as any;
                for (let item of _data["phoneNumbers"])
                    this.phoneNumbers!.push(PhoneNumber.fromJS(item));
            }
            if (Array.isArray(_data["websites"])) {
                this.websites = [] as any;
                for (let item of _data["websites"])
                    this.websites!.push(Website.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccountingEntity {
        data = typeof data === 'object' ? data : {};
        let result = new AccountingEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseCurrency"] = this.baseCurrency ? this.baseCurrency.toJSON() : <any>undefined;
        data["fiscalYearEnd"] = this.fiscalYearEnd ? this.fiscalYearEnd.toJSON() : <any>undefined;
        data["homeCountry"] = this.homeCountry ? this.homeCountry.toJSON() : <any>undefined;
        data["taxYearEnd"] = this.taxYearEnd ? this.taxYearEnd.toJSON() : <any>undefined;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item.toJSON());
        }
        if (Array.isArray(this.identifiers)) {
            data["identifiers"] = [];
            for (let item of this.identifiers)
                data["identifiers"].push(item.toJSON());
        }
        if (Array.isArray(this.names)) {
            data["names"] = [];
            for (let item of this.names)
                data["names"].push(item.toJSON());
        }
        if (Array.isArray(this.otherContactMethods)) {
            data["otherContactMethods"] = [];
            for (let item of this.otherContactMethods)
                data["otherContactMethods"].push(item.toJSON());
        }
        if (Array.isArray(this.phoneNumbers)) {
            data["phoneNumbers"] = [];
            for (let item of this.phoneNumbers)
                data["phoneNumbers"].push(item.toJSON());
        }
        if (Array.isArray(this.websites)) {
            data["websites"] = [];
            for (let item of this.websites)
                data["websites"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AccountingEntity {
        const json = this.toJSON();
        let result = new AccountingEntity();
        result.init(json);
        return result;
    }
}

/** Models the organization for which accounting and other financial data was prepared. */
export interface IAccountingEntity {
    baseCurrency?: Currency;
    fiscalYearEnd?: YearEnd;
    homeCountry?: Country;
    taxYearEnd?: YearEnd;
    /** A list of addresses. */
    addresses: Address[];
    /** A list of emails. */
    emails: EmailAddress[];
    /** A list of identifiers. */
    identifiers: Identifier[];
    /** A list of names. */
    names: OrganizationName[];
    /** A list of other contact methods. */
    otherContactMethods: OtherContactMethod[];
    /** A list of phone numbers. */
    phoneNumbers: PhoneNumber[];
    /** A list of websites. */
    websites: Website[];
}

/** Models options for importing accounting data. */
export class AccountingImportOptions implements IAccountingImportOptions {
    /** Used to specify privacy controls to be applied to the imported financial data. */
    privacyControls!: PrivacyControl[];
    transactions!: TransactionImportOptions;
    financialStatements!: FinancialStatementImportOptions;
    receivables!: ReceivablesAndPayablesOptions;
    payables!: ReceivablesAndPayablesOptions;

    constructor(data?: IAccountingImportOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.privacyControls = [];
            this.transactions = new TransactionImportOptions();
            this.financialStatements = new FinancialStatementImportOptions();
            this.receivables = new ReceivablesAndPayablesOptions();
            this.payables = new ReceivablesAndPayablesOptions();
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["privacyControls"])) {
                this.privacyControls = [] as any;
                for (let item of _data["privacyControls"])
                    this.privacyControls!.push(item);
            }
            this.transactions = _data["transactions"] ? TransactionImportOptions.fromJS(_data["transactions"]) : new TransactionImportOptions();
            this.financialStatements = _data["financialStatements"] ? FinancialStatementImportOptions.fromJS(_data["financialStatements"]) : new FinancialStatementImportOptions();
            this.receivables = _data["receivables"] ? ReceivablesAndPayablesOptions.fromJS(_data["receivables"]) : new ReceivablesAndPayablesOptions();
            this.payables = _data["payables"] ? ReceivablesAndPayablesOptions.fromJS(_data["payables"]) : new ReceivablesAndPayablesOptions();
        }
    }

    static fromJS(data: any): AccountingImportOptions {
        data = typeof data === 'object' ? data : {};
        let result = new AccountingImportOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.privacyControls)) {
            data["privacyControls"] = [];
            for (let item of this.privacyControls)
                data["privacyControls"].push(item);
        }
        data["transactions"] = this.transactions ? this.transactions.toJSON() : <any>undefined;
        data["financialStatements"] = this.financialStatements ? this.financialStatements.toJSON() : <any>undefined;
        data["receivables"] = this.receivables ? this.receivables.toJSON() : <any>undefined;
        data["payables"] = this.payables ? this.payables.toJSON() : <any>undefined;
        return data; 
    }

    clone(): AccountingImportOptions {
        const json = this.toJSON();
        let result = new AccountingImportOptions();
        result.init(json);
        return result;
    }
}

/** Models options for importing accounting data. */
export interface IAccountingImportOptions {
    /** Used to specify privacy controls to be applied to the imported financial data. */
    privacyControls: PrivacyControl[];
    transactions: TransactionImportOptions;
    financialStatements: FinancialStatementImportOptions;
    receivables: ReceivablesAndPayablesOptions;
    payables: ReceivablesAndPayablesOptions;
}

/** The kind of an account can be either real or nominal. |Enum Value|Description| |--|--| |Real|Real or permanent account balances carry over to the next fiscal year. This includes Asset, Liability, and Equity accounts.| |Nominal|Nominal accounts are reset at the end of each fiscal year. This includes Revenue and Expense accounts.| */
export type AccountKind = "Real" | "Nominal";

/** A reference to an account for which full details can be found in the Chart Of Accounts. */
export class AccountReference implements IAccountReference {
    /** An identifier for an account in the Chart Of Accounts. */
    accountId!: string;

    constructor(data?: IAccountReference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"];
        }
    }

    static fromJS(data: any): AccountReference {
        data = typeof data === 'object' ? data : {};
        let result = new AccountReference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        return data; 
    }

    clone(): AccountReference {
        const json = this.toJSON();
        let result = new AccountReference();
        result.init(json);
        return result;
    }
}

/** A reference to an account for which full details can be found in the Chart Of Accounts. */
export interface IAccountReference {
    /** An identifier for an account in the Chart Of Accounts. */
    accountId: string;
}

/** Models the starting, ending, and total change in account balance for a specific account. */
export class AccountSummary implements IAccountSummary {
    /** An identifier for the account. */
    accountId!: string;
    endingBalance!: DoubleEntryAmount;
    netChange!: DoubleEntryAmount;
    startingBalance!: DoubleEntryAmount;

    constructor(data?: IAccountSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.endingBalance = new DoubleEntryAmount();
            this.netChange = new DoubleEntryAmount();
            this.startingBalance = new DoubleEntryAmount();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"];
            this.endingBalance = _data["endingBalance"] ? DoubleEntryAmount.fromJS(_data["endingBalance"]) : new DoubleEntryAmount();
            this.netChange = _data["netChange"] ? DoubleEntryAmount.fromJS(_data["netChange"]) : new DoubleEntryAmount();
            this.startingBalance = _data["startingBalance"] ? DoubleEntryAmount.fromJS(_data["startingBalance"]) : new DoubleEntryAmount();
        }
    }

    static fromJS(data: any): AccountSummary {
        data = typeof data === 'object' ? data : {};
        let result = new AccountSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["endingBalance"] = this.endingBalance ? this.endingBalance.toJSON() : <any>undefined;
        data["netChange"] = this.netChange ? this.netChange.toJSON() : <any>undefined;
        data["startingBalance"] = this.startingBalance ? this.startingBalance.toJSON() : <any>undefined;
        return data; 
    }

    clone(): AccountSummary {
        const json = this.toJSON();
        let result = new AccountSummary();
        result.init(json);
        return result;
    }
}

/** Models the starting, ending, and total change in account balance for a specific account. */
export interface IAccountSummary {
    /** An identifier for the account. */
    accountId: string;
    endingBalance: DoubleEntryAmount;
    netChange: DoubleEntryAmount;
    startingBalance: DoubleEntryAmount;
}

/** Account Totals model the starting, ending, and total change in account balance by reporting period. */
export class AccountTotals implements IAccountTotals {
    /** Totals for each account by reporting period. */
    reportedTotals!: ReportedAccountTotals[];
    reportingPeriod!: ReportingPeriod;

    constructor(data?: IAccountTotals) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.reportedTotals = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["reportedTotals"])) {
                this.reportedTotals = [] as any;
                for (let item of _data["reportedTotals"])
                    this.reportedTotals!.push(ReportedAccountTotals.fromJS(item));
            }
            this.reportingPeriod = _data["reportingPeriod"];
        }
    }

    static fromJS(data: any): AccountTotals {
        data = typeof data === 'object' ? data : {};
        let result = new AccountTotals();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.reportedTotals)) {
            data["reportedTotals"] = [];
            for (let item of this.reportedTotals)
                data["reportedTotals"].push(item.toJSON());
        }
        data["reportingPeriod"] = this.reportingPeriod;
        return data; 
    }

    clone(): AccountTotals {
        const json = this.toJSON();
        let result = new AccountTotals();
        result.init(json);
        return result;
    }
}

/** Account Totals model the starting, ending, and total change in account balance by reporting period. */
export interface IAccountTotals {
    /** Totals for each account by reporting period. */
    reportedTotals: ReportedAccountTotals[];
    reportingPeriod: ReportingPeriod;
}

/** Models a mailing address. */
export class Address implements IAddress {
    /** Specific parts of the address that have been identified. The set of Components does not necessarily provide a complete representation of the address. */
    components!: AddressComponent[];
    /** A complete representation of the address without any implied structure or formatting. */
    freeFormLines!: string[];
    /** A set of tags for the address intended to identify how the address is used. */
    tags!: AddressTag[];

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.components = [];
            this.freeFormLines = [];
            this.tags = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["components"])) {
                this.components = [] as any;
                for (let item of _data["components"])
                    this.components!.push(AddressComponent.fromJS(item));
            }
            if (Array.isArray(_data["freeFormLines"])) {
                this.freeFormLines = [] as any;
                for (let item of _data["freeFormLines"])
                    this.freeFormLines!.push(item);
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.components)) {
            data["components"] = [];
            for (let item of this.components)
                data["components"].push(item.toJSON());
        }
        if (Array.isArray(this.freeFormLines)) {
            data["freeFormLines"] = [];
            for (let item of this.freeFormLines)
                data["freeFormLines"].push(item);
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data; 
    }

    clone(): Address {
        const json = this.toJSON();
        let result = new Address();
        result.init(json);
        return result;
    }
}

/** Models a mailing address. */
export interface IAddress {
    /** Specific parts of the address that have been identified. The set of Components does not necessarily provide a complete representation of the address. */
    components: AddressComponent[];
    /** A complete representation of the address without any implied structure or formatting. */
    freeFormLines: string[];
    /** A set of tags for the address intended to identify how the address is used. */
    tags: AddressTag[];
}

/** Models a part of an address that has been identified. */
export class AddressComponent implements IAddressComponent {
    type!: ComponentOfAddress;
    /** A value for the part of the address that has been identified with no implied formatting. */
    value!: string;

    constructor(data?: IAddressComponent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): AddressComponent {
        data = typeof data === 'object' ? data : {};
        let result = new AddressComponent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["value"] = this.value;
        return data; 
    }

    clone(): AddressComponent {
        const json = this.toJSON();
        let result = new AddressComponent();
        result.init(json);
        return result;
    }
}

/** Models a part of an address that has been identified. */
export interface IAddressComponent {
    type: ComponentOfAddress;
    /** A value for the part of the address that has been identified with no implied formatting. */
    value: string;
}

/** Defines a set of tags providing additional information about an address. |Enum Value|Description| |--|--| |POBox|The address represents a postal box rather than a physical address.| |Shipping|The address is used for delivery or receipt of products.| |Contact|The address is used as a public contact address.| |Invoicing|The address is used for invoicing.| |Legal|The address is used for legal purposes.| |Billing|The address is used for billing purposes.| */
export type AddressTag = "POBox" | "Shipping" | "Contact" | "Invoicing" | "Legal" | "Billing";

/** This response may be used to describe a client error when returning a 400 HTTP status code. */
export class BadRequest implements IBadRequest {
    /** A description of the client error. */
    description!: string;
    /** The name of the parameter that was invalid, if applicable.
May be null or omitted. */
    parameter?: string | undefined;

    constructor(data?: IBadRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.parameter = _data["parameter"];
        }
    }

    static fromJS(data: any): BadRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BadRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["parameter"] = this.parameter;
        return data; 
    }

    clone(): BadRequest {
        const json = this.toJSON();
        let result = new BadRequest();
        result.init(json);
        return result;
    }
}

/** This response may be used to describe a client error when returning a 400 HTTP status code. */
export interface IBadRequest {
    /** A description of the client error. */
    description: string;
    /** The name of the parameter that was invalid, if applicable.
May be null or omitted. */
    parameter?: string | undefined;
}

/** Models options for selecting the base figures to use when running a vertical analysis against the Balance Sheet. |Enum Value|Description| |--|--| |TotalAssets|All line items are compared against Total Assets.| |TotalAssetsTotalLiabilitiesAndTotalEquity|All assets are compared against Total Assets, all liabilities against Total Liabilities, and all equity accounts are compared against Total Equity.| */
export type BalanceSheetBaseFigures = "TotalAssets" | "TotalAssetsTotalLiabilitiesAndTotalEquity";

/** A Vertical Analysis of Balance Sheet line items. */
export class BalanceSheetVerticalAnalysis implements IBalanceSheetVerticalAnalysis {
    baseFigures!: BalanceSheetBaseFigures;
    /** Vertical Analysis comparative data by line item. */
    lineItems!: VerticalAnalysisLineItem[];

    constructor(data?: IBalanceSheetVerticalAnalysis) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.lineItems = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baseFigures = _data["baseFigures"];
            if (Array.isArray(_data["lineItems"])) {
                this.lineItems = [] as any;
                for (let item of _data["lineItems"])
                    this.lineItems!.push(VerticalAnalysisLineItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BalanceSheetVerticalAnalysis {
        data = typeof data === 'object' ? data : {};
        let result = new BalanceSheetVerticalAnalysis();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseFigures"] = this.baseFigures;
        if (Array.isArray(this.lineItems)) {
            data["lineItems"] = [];
            for (let item of this.lineItems)
                data["lineItems"].push(item.toJSON());
        }
        return data; 
    }

    clone(): BalanceSheetVerticalAnalysis {
        const json = this.toJSON();
        let result = new BalanceSheetVerticalAnalysis();
        result.init(json);
        return result;
    }
}

/** A Vertical Analysis of Balance Sheet line items. */
export interface IBalanceSheetVerticalAnalysis {
    baseFigures: BalanceSheetBaseFigures;
    /** Vertical Analysis comparative data by line item. */
    lineItems: VerticalAnalysisLineItem[];
}

/** Defines possible options for selecting baseline period(s) to use for a Horizontal Analysis. |Enum Value|Description| |--|--| |YoY|Each full fiscal year is compared to the prior fiscal year.| |YoYAndTTM|Each full fiscal year is compared to the prior fiscal year, and the TTM period is compared to the last closed fiscal year.| |YoYByQuarter|Each fiscal quarter is compared to the same quarter of the prior fiscal year.| |YoYByMonth|Each month is compared to the same month of the prior fiscal year.| |InterimYoY|Each interim year is compared to the previous, where the interim year is defined by the number of months completed in the current fiscal year.| |CalendarYoY|Each calendar year is compared to the prior calendar year.| |CalendarYoYByQuarter|Each quarter is compared to the same quarter of the prior calendar year.| |CalendarYoYByMonth|Each month is compared to the same month of the prior calendar year.| |Rolling12MonthsYoY|Each rolling 12 month period is compared to the previous rolling 12 month period.| |QoQ|Each fiscal quarter is compared to the previous fiscal quarter.| |CalendarQoQ|Each quarter of the calendar year is compared to the previous quarter.| |MoM|Each month is compared to the previous month.| |FirstMonth|Each month is compared to the first available month.| |FirstQuarter|Each fiscal quarter is compared to the first available fiscal quarter.| |FirstCalendarQuarter|Each quarter of the calendar year is compared to the first available quarter.| |FirstYear|Each fiscal year is compared to the first available fiscal year.| |FirstCalendarYear|Each calendar year is compared to the first available calendar year.| |FirstInterimYear|Each interim year is compared to the first available, where the interim year is defined by the number of months completed in the current fiscal year.| |FirstRolling12Months|Each rolling 12 month period is compared to the first available rolling 12 month period.| */
export type BaselinePeriodType = "YoY" | "YoYAndTTM" | "YoYByQuarter" | "YoYByMonth" | "InterimYoY" | "CalendarYoY" | "CalendarYoYByQuarter" | "CalendarYoYByMonth" | "Rolling12MonthsYoY" | "QoQ" | "CalendarQoQ" | "MoM" | "FirstMonth" | "FirstQuarter" | "FirstCalendarQuarter" | "FirstYear" | "FirstCalendarYear" | "FirstInterimYear" | "FirstRolling12Months";

/** Specifies the Basis Of Accounting used to prepare financial data. |Enum Value|Description| |--|--| |Accrual|Import financial data on an accrual basis if possible.| |Cash|Import financial data on a cash basis if possible.| */
export type BasisOfAccounting = "Accrual" | "Cash";

/** Specifies preferences for the Basis Of Accounting to use when importing financial data from an accounting system. |Enum Value|Description| |--|--| |Accrual|Import financial data on an accrual basis if possible.| |Cash|Import financial data on a cash basis if possible.| |CashAndAccrual|Import financial data on both a cash and accrual basis if possible.| */
export type BasisOfAccountingPreference = "Accrual" | "Cash" | "CashAndAccrual";

/** Models an id and name for a person or organization with which the business transacts. For example, a customer, vendor, employee, or shareholder. */
export class BusinessRelationship implements IBusinessRelationship {
    /** An identifier for the business relationship, if specified. */
    id?: string | undefined;
    /** The name associated with the business relationship, if specified. */
    name?: string | undefined;

    constructor(data?: IBusinessRelationship) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): BusinessRelationship {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRelationship();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): BusinessRelationship {
        const json = this.toJSON();
        let result = new BusinessRelationship();
        result.init(json);
        return result;
    }
}

/** Models an id and name for a person or organization with which the business transacts. For example, a customer, vendor, employee, or shareholder. */
export interface IBusinessRelationship {
    /** An identifier for the business relationship, if specified. */
    id?: string | undefined;
    /** The name associated with the business relationship, if specified. */
    name?: string | undefined;
}

/** Models error codes related to issues calculating mathematical formulas. |Enum Value|Description| |--|--| |Unknown|An unexpected error occurred during calculation.| |DivideByZero|Unable to evaluate the formula because divide by zero is not defined.| */
export type CalculationError = "Unknown" | "DivideByZero";

/** Models a Chart Of Accounts, which provides a hierarchical listing of all accounts used for financial reporting. */
export class ChartOfAccounts implements IChartOfAccounts {
    /** A hierarchical representation of the accounts used for financial reporting. */
    hierarchy!: Account[];

    constructor(data?: IChartOfAccounts) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.hierarchy = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["hierarchy"])) {
                this.hierarchy = [] as any;
                for (let item of _data["hierarchy"])
                    this.hierarchy!.push(Account.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChartOfAccounts {
        data = typeof data === 'object' ? data : {};
        let result = new ChartOfAccounts();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.hierarchy)) {
            data["hierarchy"] = [];
            for (let item of this.hierarchy)
                data["hierarchy"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ChartOfAccounts {
        const json = this.toJSON();
        let result = new ChartOfAccounts();
        result.init(json);
        return result;
    }
}

/** Models a Chart Of Accounts, which provides a hierarchical listing of all accounts used for financial reporting. */
export interface IChartOfAccounts {
    /** A hierarchical representation of the accounts used for financial reporting. */
    hierarchy: Account[];
}

/** Defines how an account appearing in the Chart Of Accounts is used. |Enum Value|Description| |--|--| |Bookkeeping|The account is used to record business transactions. Many accounting systems refer to these as 'Detail Accounts'.| |ReportHeader|The account is used for presentation purposes only. Many accounting systems refer to these accounts as 'Header Accounts'.| */
export type ChartOfAccountsRole = "Bookkeeping" | "ReportHeader";

/** Specifies the desired chronological sort order. |Enum Value|Description| |--|--| |OldestFirst|Older data is ordered before more recent data.| |NewestFirst|More recent data is ordered before older data.| */
export type ChronologicalSortOrder = "OldestFirst" | "NewestFirst";

/** Models a column header for a comparative financial statement. The column header contains information about the reporting period associated with each column. */
export class ColumnHeader implements IColumnHeader {
    /** A label for the column header. For example "FY 2019". */
    label?: string | undefined;
    /** The end date of the reporting period for which the financial data was prepared (inclusive). */
    reportingEndDate!: string;
    /** The start date of the reporting period for which the financial data was prepared (inclusive). May be null for point-in-time statements such as the Balance Sheet. */
    reportingStartDate?: string | undefined;

    constructor(data?: IColumnHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.reportingEndDate = _data["reportingEndDate"];
            this.reportingStartDate = _data["reportingStartDate"];
        }
    }

    static fromJS(data: any): ColumnHeader {
        data = typeof data === 'object' ? data : {};
        let result = new ColumnHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["reportingEndDate"] = this.reportingEndDate;
        data["reportingStartDate"] = this.reportingStartDate;
        return data; 
    }

    clone(): ColumnHeader {
        const json = this.toJSON();
        let result = new ColumnHeader();
        result.init(json);
        return result;
    }
}

/** Models a column header for a comparative financial statement. The column header contains information about the reporting period associated with each column. */
export interface IColumnHeader {
    /** A label for the column header. For example "FY 2019". */
    label?: string | undefined;
    /** The end date of the reporting period for which the financial data was prepared (inclusive). */
    reportingEndDate: string;
    /** The start date of the reporting period for which the financial data was prepared (inclusive). May be null for point-in-time statements such as the Balance Sheet. */
    reportingStartDate?: string | undefined;
}

/** Models a Comparative Balance Sheet (aka The Statement of Financial Position). */
export class ComparativeBalanceSheet implements IComparativeBalanceSheet {
    accountingMethod!: BasisOfAccounting;
    /** The column headers contain information about the reporting periods represented in the comparative financial statement. */
    columnHeaders!: ColumnHeader[];
    currency?: Currency;
    /** An optional set of notes for the financial statement. May be empty. */
    footnotes!: string[];
    /** The set of line items appearing in the financial statement. */
    lineItems!: LineItem[];
    /** The name of the organization associated with the financial statement. May be null. */
    organizationName?: string | undefined;
    /** A whole number indicating if, for example, monetary amounts are represented in actual (1), thousands (1,000), or millions (1,000,000). */
    scalingFactor!: number;
    /** The time at which the financial statement was prepared. */
    dataAsOfTime!: string;
    /** A title for the financial statement that was prepared. Example: "Balance Sheet". */
    title!: string;

    constructor(data?: IComparativeBalanceSheet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.columnHeaders = [];
            this.footnotes = [];
            this.lineItems = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountingMethod = _data["accountingMethod"];
            if (Array.isArray(_data["columnHeaders"])) {
                this.columnHeaders = [] as any;
                for (let item of _data["columnHeaders"])
                    this.columnHeaders!.push(ColumnHeader.fromJS(item));
            }
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
            if (Array.isArray(_data["footnotes"])) {
                this.footnotes = [] as any;
                for (let item of _data["footnotes"])
                    this.footnotes!.push(item);
            }
            if (Array.isArray(_data["lineItems"])) {
                this.lineItems = [] as any;
                for (let item of _data["lineItems"])
                    this.lineItems!.push(LineItem.fromJS(item));
            }
            this.organizationName = _data["organizationName"];
            this.scalingFactor = _data["scalingFactor"];
            this.dataAsOfTime = _data["dataAsOfTime"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): ComparativeBalanceSheet {
        data = typeof data === 'object' ? data : {};
        let result = new ComparativeBalanceSheet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountingMethod"] = this.accountingMethod;
        if (Array.isArray(this.columnHeaders)) {
            data["columnHeaders"] = [];
            for (let item of this.columnHeaders)
                data["columnHeaders"].push(item.toJSON());
        }
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        if (Array.isArray(this.footnotes)) {
            data["footnotes"] = [];
            for (let item of this.footnotes)
                data["footnotes"].push(item);
        }
        if (Array.isArray(this.lineItems)) {
            data["lineItems"] = [];
            for (let item of this.lineItems)
                data["lineItems"].push(item.toJSON());
        }
        data["organizationName"] = this.organizationName;
        data["scalingFactor"] = this.scalingFactor;
        data["dataAsOfTime"] = this.dataAsOfTime;
        data["title"] = this.title;
        return data; 
    }

    clone(): ComparativeBalanceSheet {
        const json = this.toJSON();
        let result = new ComparativeBalanceSheet();
        result.init(json);
        return result;
    }
}

/** Models a Comparative Balance Sheet (aka The Statement of Financial Position). */
export interface IComparativeBalanceSheet {
    accountingMethod: BasisOfAccounting;
    /** The column headers contain information about the reporting periods represented in the comparative financial statement. */
    columnHeaders: ColumnHeader[];
    currency?: Currency;
    /** An optional set of notes for the financial statement. May be empty. */
    footnotes: string[];
    /** The set of line items appearing in the financial statement. */
    lineItems: LineItem[];
    /** The name of the organization associated with the financial statement. May be null. */
    organizationName?: string | undefined;
    /** A whole number indicating if, for example, monetary amounts are represented in actual (1), thousands (1,000), or millions (1,000,000). */
    scalingFactor: number;
    /** The time at which the financial statement was prepared. */
    dataAsOfTime: string;
    /** A title for the financial statement that was prepared. Example: "Balance Sheet". */
    title: string;
}

/** Models a Comparative Income Statement (aka The Profit and Loss Statement). */
export class ComparativeIncomeStatement implements IComparativeIncomeStatement {
    accountingMethod!: BasisOfAccounting;
    /** The column headers contain information about the reporting periods represented in the comparative financial statement. */
    columnHeaders!: ColumnHeader[];
    currency?: Currency;
    /** An optional set of notes for the financial statement. May be empty. */
    footnotes!: string[];
    /** The set of line items appearing in the financial statement. */
    lineItems!: LineItem[];
    /** The name of the organization associated with the financial statement. May be null. */
    organizationName?: string | undefined;
    /** A whole number indicating if, for example, monetary amounts are represented in actual (1), thousands (1,000), or millions (1,000,000). */
    scalingFactor!: number;
    /** The time at which the financial statement was prepared. */
    dataAsOfTime!: string;
    /** A title for the financial statement that was prepared. Example: "Balance Sheet". */
    title!: string;

    constructor(data?: IComparativeIncomeStatement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.columnHeaders = [];
            this.footnotes = [];
            this.lineItems = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountingMethod = _data["accountingMethod"];
            if (Array.isArray(_data["columnHeaders"])) {
                this.columnHeaders = [] as any;
                for (let item of _data["columnHeaders"])
                    this.columnHeaders!.push(ColumnHeader.fromJS(item));
            }
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
            if (Array.isArray(_data["footnotes"])) {
                this.footnotes = [] as any;
                for (let item of _data["footnotes"])
                    this.footnotes!.push(item);
            }
            if (Array.isArray(_data["lineItems"])) {
                this.lineItems = [] as any;
                for (let item of _data["lineItems"])
                    this.lineItems!.push(LineItem.fromJS(item));
            }
            this.organizationName = _data["organizationName"];
            this.scalingFactor = _data["scalingFactor"];
            this.dataAsOfTime = _data["dataAsOfTime"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): ComparativeIncomeStatement {
        data = typeof data === 'object' ? data : {};
        let result = new ComparativeIncomeStatement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountingMethod"] = this.accountingMethod;
        if (Array.isArray(this.columnHeaders)) {
            data["columnHeaders"] = [];
            for (let item of this.columnHeaders)
                data["columnHeaders"].push(item.toJSON());
        }
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        if (Array.isArray(this.footnotes)) {
            data["footnotes"] = [];
            for (let item of this.footnotes)
                data["footnotes"].push(item);
        }
        if (Array.isArray(this.lineItems)) {
            data["lineItems"] = [];
            for (let item of this.lineItems)
                data["lineItems"].push(item.toJSON());
        }
        data["organizationName"] = this.organizationName;
        data["scalingFactor"] = this.scalingFactor;
        data["dataAsOfTime"] = this.dataAsOfTime;
        data["title"] = this.title;
        return data; 
    }

    clone(): ComparativeIncomeStatement {
        const json = this.toJSON();
        let result = new ComparativeIncomeStatement();
        result.init(json);
        return result;
    }
}

/** Models a Comparative Income Statement (aka The Profit and Loss Statement). */
export interface IComparativeIncomeStatement {
    accountingMethod: BasisOfAccounting;
    /** The column headers contain information about the reporting periods represented in the comparative financial statement. */
    columnHeaders: ColumnHeader[];
    currency?: Currency;
    /** An optional set of notes for the financial statement. May be empty. */
    footnotes: string[];
    /** The set of line items appearing in the financial statement. */
    lineItems: LineItem[];
    /** The name of the organization associated with the financial statement. May be null. */
    organizationName?: string | undefined;
    /** A whole number indicating if, for example, monetary amounts are represented in actual (1), thousands (1,000), or millions (1,000,000). */
    scalingFactor: number;
    /** The time at which the financial statement was prepared. */
    dataAsOfTime: string;
    /** A title for the financial statement that was prepared. Example: "Balance Sheet". */
    title: string;
}

/** Defines the set of address component types that can be identified. |Enum Value|Description| |--|--| |Addressee|A name for a person, organization, building, or venue appearing as part of the address.| |POBoxNumber|A Postal Box number.| |Unit|An apartment, unit, office, lot, or room number.| |Floor|A floor number| |StreetAndNumber|A street or route name and building number.| |Neighborhood|A suburb or other unofficial neighborhood name.| |District|A district, borough, or other second-level municipality.| |PostalCode|A postal / zip code.| |City|The name of a city, town, village, hamlet, locality, or other first-level municipality.| |County|A second-level administrative division for a country.| |StateOrProvince|A first-level administrative division for a country.| |Region|An informal geographic region smaller than a country including named islands.| |Country|Sovereign nations and their dependent territories. See ISO 3166-1.| |WorldRegion|An informal geographic region larger than a country.| */
export type ComponentOfAddress = "Addressee" | "POBoxNumber" | "Unit" | "Floor" | "StreetAndNumber" | "Neighborhood" | "District" | "PostalCode" | "City" | "County" | "StateOrProvince" | "Region" | "Country" | "WorldRegion";

/** Defines the types of phone number components. |Enum Value|Description| |--|--| |AreaCode|A numeric prefix used by various telephone numbering plans for routing between geographic areas and for provisioning.| |CountryCallingCode|A telephone number prefix that is used for international calls.| |Extension|An extension number for the phone number.| |NationalNumber|A representation of the phone number excluding the Country Calling Code and any extension, but including area code [for numbering plans having one]. Domestic calls can be made using the national number alone.| |LocalNumber|The local part of the phone number excluding the area code. 7-digits in the NANP.| */
export type ComponentOfPhoneNumber = "AreaCode" | "CountryCallingCode" | "Extension" | "NationalNumber" | "LocalNumber";

/** Models a Connection to an external Dataset. */
export class Connection implements IConnection {
    state!: ConnectionState;
    /** An identifier for the external Dataset associated with the Connection. */
    datasetId!: string;
    /** A friendly name for the external Dataset associated with the Connection. */
    datasetName?: string | undefined;
    /** The name identifier of a datasource. Ex: 'quickbooksonline'. */
    datasourceNameId!: string;
    /** An identifier for the Connection. */
    id!: string;
    /** An identifier for the Organization for which the Connection was created. */
    orgId!: string;

    constructor(data?: IConnection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.datasetId = _data["datasetId"];
            this.datasetName = _data["datasetName"];
            this.datasourceNameId = _data["datasourceNameId"];
            this.id = _data["id"];
            this.orgId = _data["orgId"];
        }
    }

    static fromJS(data: any): Connection {
        data = typeof data === 'object' ? data : {};
        let result = new Connection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["datasetId"] = this.datasetId;
        data["datasetName"] = this.datasetName;
        data["datasourceNameId"] = this.datasourceNameId;
        data["id"] = this.id;
        data["orgId"] = this.orgId;
        return data; 
    }

    clone(): Connection {
        const json = this.toJSON();
        let result = new Connection();
        result.init(json);
        return result;
    }
}

/** Models a Connection to an external Dataset. */
export interface IConnection {
    state: ConnectionState;
    /** An identifier for the external Dataset associated with the Connection. */
    datasetId: string;
    /** A friendly name for the external Dataset associated with the Connection. */
    datasetName?: string | undefined;
    /** The name identifier of a datasource. Ex: 'quickbooksonline'. */
    datasourceNameId: string;
    /** An identifier for the Connection. */
    id: string;
    /** An identifier for the Organization for which the Connection was created. */
    orgId: string;
}

/** A descriptor for a Connection to an external Dataset. */
export class ConnectionDescriptor implements IConnectionDescriptor {
    /** An identifier for the external Dataset associated with the Connection. */
    datasetId!: string;
    /** A friendly name for the external Dataset associated with the Connection. */
    datasetName?: string | undefined;
    /** The name identifier of a datasource. Ex: 'quickbooksonline'. */
    datasourceNameId!: string;
    /** An identifier for the Connection. */
    id!: string;
    /** An identifier for the Organization for which the Connection was created. */
    orgId!: string;

    constructor(data?: IConnectionDescriptor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.datasetId = _data["datasetId"];
            this.datasetName = _data["datasetName"];
            this.datasourceNameId = _data["datasourceNameId"];
            this.id = _data["id"];
            this.orgId = _data["orgId"];
        }
    }

    static fromJS(data: any): ConnectionDescriptor {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectionDescriptor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["datasetId"] = this.datasetId;
        data["datasetName"] = this.datasetName;
        data["datasourceNameId"] = this.datasourceNameId;
        data["id"] = this.id;
        data["orgId"] = this.orgId;
        return data; 
    }

    clone(): ConnectionDescriptor {
        const json = this.toJSON();
        let result = new ConnectionDescriptor();
        result.init(json);
        return result;
    }
}

/** A descriptor for a Connection to an external Dataset. */
export interface IConnectionDescriptor {
    /** An identifier for the external Dataset associated with the Connection. */
    datasetId: string;
    /** A friendly name for the external Dataset associated with the Connection. */
    datasetName?: string | undefined;
    /** The name identifier of a datasource. Ex: 'quickbooksonline'. */
    datasourceNameId: string;
    /** An identifier for the Connection. */
    id: string;
    /** An identifier for the Organization for which the Connection was created. */
    orgId: string;
}

/** Models a Connection Request. */
export class ConnectionRequest implements IConnectionRequest {
    /** If the Status of the Connection Request is Success, this will be an identifier for the Connection to the datasource. */
    connectionId?: string | undefined;
    /** An identifier for the Connection Request. */
    id!: string;
    errorCode?: ConnectionRequestErrorCode;
    /** If the Status of the Connection Request is Error, and ErrorDescription provides a user friendly description of to better understand why the Connection Request was not successful. */
    errorDescription?: string | undefined;
    /** An identifier for the Organization for which the datasource is being connected. */
    orgId!: string;
    status!: ConnectionRequestStatus;
    /** A name identifier for the datasource being connected to. */
    datasourceNameId!: string;

    constructor(data?: IConnectionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.connectionId = _data["connectionId"];
            this.id = _data["id"];
            this.errorCode = _data["errorCode"];
            this.errorDescription = _data["errorDescription"];
            this.orgId = _data["orgId"];
            this.status = _data["status"];
            this.datasourceNameId = _data["datasourceNameId"];
        }
    }

    static fromJS(data: any): ConnectionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionId"] = this.connectionId;
        data["id"] = this.id;
        data["errorCode"] = this.errorCode;
        data["errorDescription"] = this.errorDescription;
        data["orgId"] = this.orgId;
        data["status"] = this.status;
        data["datasourceNameId"] = this.datasourceNameId;
        return data; 
    }

    clone(): ConnectionRequest {
        const json = this.toJSON();
        let result = new ConnectionRequest();
        result.init(json);
        return result;
    }
}

/** Models a Connection Request. */
export interface IConnectionRequest {
    /** If the Status of the Connection Request is Success, this will be an identifier for the Connection to the datasource. */
    connectionId?: string | undefined;
    /** An identifier for the Connection Request. */
    id: string;
    errorCode?: ConnectionRequestErrorCode;
    /** If the Status of the Connection Request is Error, and ErrorDescription provides a user friendly description of to better understand why the Connection Request was not successful. */
    errorDescription?: string | undefined;
    /** An identifier for the Organization for which the datasource is being connected. */
    orgId: string;
    status: ConnectionRequestStatus;
    /** A name identifier for the datasource being connected to. */
    datasourceNameId: string;
}

/** A descriptor for a newly created Connnection Request. */
export class ConnectionRequestDescriptor implements IConnectionRequestDescriptor {
    /** The URL to which the user should be directed for them to connect the datasource. */
    connectionEndpoint?: string | undefined;
    /** The `connectionEndpoint` URL in this response cannot be used beyond this expiration time. */
    expiration!: string;
    /** An identifier for the Connection Request. */
    id!: string;
    /** An identifier for the Organization for which the datasource is being connected. */
    orgId!: string;
    /** A name identifier for the datasource being connected to. */
    datasourceNameId!: string;

    constructor(data?: IConnectionRequestDescriptor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.connectionEndpoint = _data["connectionEndpoint"];
            this.expiration = _data["expiration"];
            this.id = _data["id"];
            this.orgId = _data["orgId"];
            this.datasourceNameId = _data["datasourceNameId"];
        }
    }

    static fromJS(data: any): ConnectionRequestDescriptor {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectionRequestDescriptor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionEndpoint"] = this.connectionEndpoint;
        data["expiration"] = this.expiration;
        data["id"] = this.id;
        data["orgId"] = this.orgId;
        data["datasourceNameId"] = this.datasourceNameId;
        return data; 
    }

    clone(): ConnectionRequestDescriptor {
        const json = this.toJSON();
        let result = new ConnectionRequestDescriptor();
        result.init(json);
        return result;
    }
}

/** A descriptor for a newly created Connnection Request. */
export interface IConnectionRequestDescriptor {
    /** The URL to which the user should be directed for them to connect the datasource. */
    connectionEndpoint?: string | undefined;
    /** The `connectionEndpoint` URL in this response cannot be used beyond this expiration time. */
    expiration: string;
    /** An identifier for the Connection Request. */
    id: string;
    /** An identifier for the Organization for which the datasource is being connected. */
    orgId: string;
    /** A name identifier for the datasource being connected to. */
    datasourceNameId: string;
}

/** Specifies the high-level reason why a Connection Request was not successful. |Enum Value|Description| |--|--| |None|No error.| |UserCancelled|The user chose not to grant access to the datasource.| |RequestNonceAlreadyUsed|The Connection Request failed because it was attempted more than once.| |RequestExpired|The Connection Request failed because it was not completed within the required time frame.| |DatasourceUnresponsive|The Connection Request failed because the datasource was not responsive or returned an error. For example, 503 or 500 response received and re-attempting to did help.| |InsufficientUserPermissions|The user did not have sufficient privileges to grant access to the datasource.| |InternalError|An internal error occured. Reach out to our support team to get help.| */
export type ConnectionRequestErrorCode = "None" | "UserCancelled" | "RequestNonceAlreadyUsed" | "RequestExpired" | "DatasourceUnresponsive" | "InsufficientUserPermissions" | "InternalError";

/** Represents the parameters that are required to create a Connection Request. */
export class ConnectionRequestParameters implements IConnectionRequestParameters {
    /** A name identifier for the datasource being connected to. */
    datasourceNameId!: string;

    constructor(data?: IConnectionRequestParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.datasourceNameId = _data["datasourceNameId"];
        }
    }

    static fromJS(data: any): ConnectionRequestParameters {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectionRequestParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["datasourceNameId"] = this.datasourceNameId;
        return data; 
    }

    clone(): ConnectionRequestParameters {
        const json = this.toJSON();
        let result = new ConnectionRequestParameters();
        result.init(json);
        return result;
    }
}

/** Represents the parameters that are required to create a Connection Request. */
export interface IConnectionRequestParameters {
    /** A name identifier for the datasource being connected to. */
    datasourceNameId: string;
}

/** Specifies the status of a Connection Request. |Enum Value|Description| |--|--| |NotStarted|The Connection Request has been created, but has not yet started.| |Started|The Connection Request is in progress.| |Success|The Connection Request was successful.| |Error|The Connection Request was not successful.| */
export type ConnectionRequestStatus = "NotStarted" | "Started" | "Success" | "Error";

/** Models a list of Connections. */
export class ConnectionsList implements IConnectionsList {
    /** The set of Connections listed. */
    connections!: ConnectionDescriptor[];

    constructor(data?: IConnectionsList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.connections = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["connections"])) {
                this.connections = [] as any;
                for (let item of _data["connections"])
                    this.connections!.push(ConnectionDescriptor.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConnectionsList {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectionsList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.connections)) {
            data["connections"] = [];
            for (let item of this.connections)
                data["connections"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ConnectionsList {
        const json = this.toJSON();
        let result = new ConnectionsList();
        result.init(json);
        return result;
    }
}

/** Models a list of Connections. */
export interface IConnectionsList {
    /** The set of Connections listed. */
    connections: ConnectionDescriptor[];
}

/** Specifies the current status of a Connection. |Enum Value|Description| |--|--| |Disconnected|The Connection can no longer be used.| |Connected|The Connection can be used.| */
export type ConnectionState = "Disconnected" | "Connected";

/** Models additional metadata that can be attached to an API resource by the API consumer. */
export class ConsumerMetadata implements IConsumerMetadata {
    /** A label or key for the metadata that can be used to identify it. */
    label!: string;
    /** A value for the metadata. Null is allowed. */
    value?: string | undefined;

    constructor(data?: IConsumerMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ConsumerMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data; 
    }

    clone(): ConsumerMetadata {
        const json = this.toJSON();
        let result = new ConsumerMetadata();
        result.init(json);
        return result;
    }
}

/** Models additional metadata that can be attached to an API resource by the API consumer. */
export interface IConsumerMetadata {
    /** A label or key for the metadata that can be used to identify it. */
    label: string;
    /** A value for the metadata. Null is allowed. */
    value?: string | undefined;
}

/** Models information about a country. */
export class Country implements ICountry {
    /** The ISO 3166 2-digit Country Code if known. */
    code?: string | undefined;
    /** A label for the country without any implied formatting or validation. */
    label!: string;

    constructor(data?: ICountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["label"] = this.label;
        return data; 
    }

    clone(): Country {
        const json = this.toJSON();
        let result = new Country();
        result.init(json);
        return result;
    }
}

/** Models information about a country. */
export interface ICountry {
    /** The ISO 3166 2-digit Country Code if known. */
    code?: string | undefined;
    /** A label for the country without any implied formatting or validation. */
    label: string;
}

/** Indicates whether an amount represents a credit, debit, or neither (zero). |Enum Value|Description| |--|--| |Zero|The amount is zero. Neither a credit or a debit.| |Credit|The amount represents a credit. Equity and liabilities typically have a credit balance. Revenue is typically credited.| |Debit|The amount represents a debit. Assets typically have a debit balance and expenses are typically debited.| */
export type CreditOrDebit = "Zero" | "Credit" | "Debit";

/** Models information about a particular currency. */
export class Currency implements ICurrency {
    /** The ISO 4217 alphabetic code if known. */
    code?: string | undefined;
    /** A label for the currency without any implied formatting or validation. */
    label!: string;

    constructor(data?: ICurrency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): Currency {
        data = typeof data === 'object' ? data : {};
        let result = new Currency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["label"] = this.label;
        return data; 
    }

    clone(): Currency {
        const json = this.toJSON();
        let result = new Currency();
        result.init(json);
        return result;
    }
}

/** Models information about a particular currency. */
export interface ICurrency {
    /** The ISO 4217 alphabetic code if known. */
    code?: string | undefined;
    /** A label for the currency without any implied formatting or validation. */
    label: string;
}

/** Models information about where financial data was sourced from. */
export class Dataset implements IDataset {
    /** An identifier for the dataset from which the financial data originated. Unique within the scope of the datasource. */
    datasetId!: string;
    /** An identifier for the Accounting System or other datasource from which the financial data originated. */
    datasourceNameId!: string;

    constructor(data?: IDataset) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.datasetId = _data["datasetId"];
            this.datasourceNameId = _data["datasourceNameId"];
        }
    }

    static fromJS(data: any): Dataset {
        data = typeof data === 'object' ? data : {};
        let result = new Dataset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["datasetId"] = this.datasetId;
        data["datasourceNameId"] = this.datasourceNameId;
        return data; 
    }

    clone(): Dataset {
        const json = this.toJSON();
        let result = new Dataset();
        result.init(json);
        return result;
    }
}

/** Models information about where financial data was sourced from. */
export interface IDataset {
    /** An identifier for the dataset from which the financial data originated. Unique within the scope of the datasource. */
    datasetId: string;
    /** An identifier for the Accounting System or other datasource from which the financial data originated. */
    datasourceNameId: string;
}

/** Used to specify whether an outstanding debt represents money owed or due. |Enum Value|Description| |--|--| |OwedTo|Money is owed to an external entity.| |DueFrom|Money is due from an external entity.| */
export type DebtDescriptor = "OwedTo" | "DueFrom";

/** Models an amount credited or debited. */
export class DoubleEntryAmount implements IDoubleEntryAmount {
    /** The scalar amount. Always positive or 0. */
    amount!: number;
    type!: CreditOrDebit;

    constructor(data?: IDoubleEntryAmount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): DoubleEntryAmount {
        data = typeof data === 'object' ? data : {};
        let result = new DoubleEntryAmount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["type"] = this.type;
        return data; 
    }

    clone(): DoubleEntryAmount {
        const json = this.toJSON();
        let result = new DoubleEntryAmount();
        result.init(json);
        return result;
    }
}

/** Models an amount credited or debited. */
export interface IDoubleEntryAmount {
    /** The scalar amount. Always positive or 0. */
    amount: number;
    type: CreditOrDebit;
}

/** Models an email address. */
export class EmailAddress implements IEmailAddress {
    /** A name or description of the contact associated with the email. For example, "John Doe" or "Customer Support". */
    contact?: string | undefined;
    /** The value for the email address without any implied formatting or validation. */
    value!: string;

    constructor(data?: IEmailAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contact = _data["contact"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): EmailAddress {
        data = typeof data === 'object' ? data : {};
        let result = new EmailAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contact"] = this.contact;
        data["value"] = this.value;
        return data; 
    }

    clone(): EmailAddress {
        const json = this.toJSON();
        let result = new EmailAddress();
        result.init(json);
        return result;
    }
}

/** Models an email address. */
export interface IEmailAddress {
    /** A name or description of the contact associated with the email. For example, "John Doe" or "Customer Support". */
    contact?: string | undefined;
    /** The value for the email address without any implied formatting or validation. */
    value: string;
}

/** Defines possible data types for fields. |Enum Value|Description| |--|--| |Numeric|The field is a numeric quantity.| */
export type FieldDataType = "Numeric";

/** Specifies the high-level reason why a Financial Import was not successful. |Enum Value|Description| |--|--| |None|No error.| |InsufficientUserPermissions|The end-user did not have or did not grant sufficient privileges to access the requested financials.| |DatasourceUnresponsive|The 3rd party service providing the financial data is not responding or has responded with one or more error messages. 5xx HTTP responses from the datasource are a typical example. Re-attempting the financial import after some time may be merited, but you can reach out to our support team so that we can help to get the issue resolved as soon as is possible.| |InternalError|An internal error occured. Reach out to our support team to get help.| |Disconnected|The Connection to the datasource requires authorization. This can happen if the authorization has expired or was revoked by the end-user. The end-user must reconnect their Accounting System or other financial datasource to import financials successfully.| |Cancelled|The financial import was cancelled by the end-user, the datasource, the API consumer, or by the Strongbox Platform.| */
export type FinancialImportErrorCode = "None" | "InsufficientUserPermissions" | "DatasourceUnresponsive" | "InternalError" | "Disconnected" | "Cancelled";

/** Specifies the outcome of importing new financial data. |Enum Value|Description| |--|--| |Pending|The outcome is still pending.| |Success|Importing the financial data is complete.| |Error|Importing the financial data failed.| */
export type FinancialImportOutcome = "Pending" | "Success" | "Error";

/** Models parameters that are required to import new financial data. */
export class FinancialImportParameters implements IFinancialImportParameters {
    /** An identifier for the Connection used to import financials. */
    accountingConnectionId!: string;
    /** Optional metadata to associate with the Financial Record. For example, you might associate the Financial Record with an identifier for a specific Loan Submission in your own system. */
    consumerMetadata?: ConsumerMetadata[] | undefined;
    /** This parameter is used as the end date for period-to-date financial data. Please use ISO 8601 date format "YYYY-MM-DD". */
    reportingEndDate!: string;
    accountingDataImportOptions?: AccountingDataImportParameters;

    constructor(data?: IFinancialImportParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountingConnectionId = _data["accountingConnectionId"];
            if (Array.isArray(_data["consumerMetadata"])) {
                this.consumerMetadata = [] as any;
                for (let item of _data["consumerMetadata"])
                    this.consumerMetadata!.push(ConsumerMetadata.fromJS(item));
            }
            this.reportingEndDate = _data["reportingEndDate"];
            this.accountingDataImportOptions = _data["accountingDataImportOptions"] ? AccountingDataImportParameters.fromJS(_data["accountingDataImportOptions"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FinancialImportParameters {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialImportParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountingConnectionId"] = this.accountingConnectionId;
        if (Array.isArray(this.consumerMetadata)) {
            data["consumerMetadata"] = [];
            for (let item of this.consumerMetadata)
                data["consumerMetadata"].push(item.toJSON());
        }
        data["reportingEndDate"] = this.reportingEndDate;
        data["accountingDataImportOptions"] = this.accountingDataImportOptions ? this.accountingDataImportOptions.toJSON() : <any>undefined;
        return data; 
    }

    clone(): FinancialImportParameters {
        const json = this.toJSON();
        let result = new FinancialImportParameters();
        result.init(json);
        return result;
    }
}

/** Models parameters that are required to import new financial data. */
export interface IFinancialImportParameters {
    /** An identifier for the Connection used to import financials. */
    accountingConnectionId: string;
    /** Optional metadata to associate with the Financial Record. For example, you might associate the Financial Record with an identifier for a specific Loan Submission in your own system. */
    consumerMetadata?: ConsumerMetadata[] | undefined;
    /** This parameter is used as the end date for period-to-date financial data. Please use ISO 8601 date format "YYYY-MM-DD". */
    reportingEndDate: string;
    accountingDataImportOptions?: AccountingDataImportParameters;
}

/** Models the status of importing new financial data to create a Financial Record. */
export class FinancialImportStatus implements IFinancialImportStatus {
    errorCode?: FinancialImportErrorCode;
    /** If the Outcome is Error, then the ErrorDescription provides a description of the problem that occurred when attempting to import financials. */
    errorDescription?: string | undefined;
    outcome!: FinancialImportOutcome;

    constructor(data?: IFinancialImportStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorCode = _data["errorCode"];
            this.errorDescription = _data["errorDescription"];
            this.outcome = _data["outcome"];
        }
    }

    static fromJS(data: any): FinancialImportStatus {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialImportStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorCode"] = this.errorCode;
        data["errorDescription"] = this.errorDescription;
        data["outcome"] = this.outcome;
        return data; 
    }

    clone(): FinancialImportStatus {
        const json = this.toJSON();
        let result = new FinancialImportStatus();
        result.init(json);
        return result;
    }
}

/** Models the status of importing new financial data to create a Financial Record. */
export interface IFinancialImportStatus {
    errorCode?: FinancialImportErrorCode;
    /** If the Outcome is Error, then the ErrorDescription provides a description of the problem that occurred when attempting to import financials. */
    errorDescription?: string | undefined;
    outcome: FinancialImportOutcome;
}

/** Models a calculated Financial Ratio. */
export class FinancialRatio implements IFinancialRatio {
    /** A unique identifier for the financial ratio. */
    id!: string;
    /** A friendly name for the ratio. */
    displayName!: string;
    /** A category assigned to the ratio. */
    category?: string | undefined;
    /** The calculated values of the ratio. */
    values!: FinancialRatioValue[];

    constructor(data?: IFinancialRatio) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.values = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.category = _data["category"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(FinancialRatioValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FinancialRatio {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialRatio();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["category"] = this.category;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data; 
    }

    clone(): FinancialRatio {
        const json = this.toJSON();
        let result = new FinancialRatio();
        result.init(json);
        return result;
    }
}

/** Models a calculated Financial Ratio. */
export interface IFinancialRatio {
    /** A unique identifier for the financial ratio. */
    id: string;
    /** A friendly name for the ratio. */
    displayName: string;
    /** A category assigned to the ratio. */
    category?: string | undefined;
    /** The calculated values of the ratio. */
    values: FinancialRatioValue[];
}

/** Models a set of calculated financial ratios. */
export class FinancialRatios implements IFinancialRatios {
    /** The set of reporting periods for which ratios were calculated. */
    reportingPeriods!: ReportingPeriodDescriptor[];
    /** The set of ratios that were calculated. */
    ratios!: FinancialRatio[];

    constructor(data?: IFinancialRatios) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.reportingPeriods = [];
            this.ratios = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["reportingPeriods"])) {
                this.reportingPeriods = [] as any;
                for (let item of _data["reportingPeriods"])
                    this.reportingPeriods!.push(ReportingPeriodDescriptor.fromJS(item));
            }
            if (Array.isArray(_data["ratios"])) {
                this.ratios = [] as any;
                for (let item of _data["ratios"])
                    this.ratios!.push(FinancialRatio.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FinancialRatios {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialRatios();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.reportingPeriods)) {
            data["reportingPeriods"] = [];
            for (let item of this.reportingPeriods)
                data["reportingPeriods"].push(item.toJSON());
        }
        if (Array.isArray(this.ratios)) {
            data["ratios"] = [];
            for (let item of this.ratios)
                data["ratios"].push(item.toJSON());
        }
        return data; 
    }

    clone(): FinancialRatios {
        const json = this.toJSON();
        let result = new FinancialRatios();
        result.init(json);
        return result;
    }
}

/** Models a set of calculated financial ratios. */
export interface IFinancialRatios {
    /** The set of reporting periods for which ratios were calculated. */
    reportingPeriods: ReportingPeriodDescriptor[];
    /** The set of ratios that were calculated. */
    ratios: FinancialRatio[];
}

/** A Horizontal Analysis of Financial Ratios. */
export class FinancialRatiosHorizontalAnalysis implements IFinancialRatiosHorizontalAnalysis {
    /** Horiztontal Analysis comparative data by Financial Ratio. */
    ratios!: HorizontalAnalysisFinancialRatio[];

    constructor(data?: IFinancialRatiosHorizontalAnalysis) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ratios = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ratios"])) {
                this.ratios = [] as any;
                for (let item of _data["ratios"])
                    this.ratios!.push(HorizontalAnalysisFinancialRatio.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FinancialRatiosHorizontalAnalysis {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialRatiosHorizontalAnalysis();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ratios)) {
            data["ratios"] = [];
            for (let item of this.ratios)
                data["ratios"].push(item.toJSON());
        }
        return data; 
    }

    clone(): FinancialRatiosHorizontalAnalysis {
        const json = this.toJSON();
        let result = new FinancialRatiosHorizontalAnalysis();
        result.init(json);
        return result;
    }
}

/** A Horizontal Analysis of Financial Ratios. */
export interface IFinancialRatiosHorizontalAnalysis {
    /** Horiztontal Analysis comparative data by Financial Ratio. */
    ratios: HorizontalAnalysisFinancialRatio[];
}

/** Models the value of a calculated ratio. */
export class FinancialRatioValue implements IFinancialRatioValue {
    errorCode?: CalculationError;
    /** The calculated value of the ratio. May be null if the ratio could not be calculated. */
    value?: number | undefined;

    constructor(data?: IFinancialRatioValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorCode = _data["errorCode"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): FinancialRatioValue {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialRatioValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorCode"] = this.errorCode;
        data["value"] = this.value;
        return data; 
    }

    clone(): FinancialRatioValue {
        const json = this.toJSON();
        let result = new FinancialRatioValue();
        result.init(json);
        return result;
    }
}

/** Models the value of a calculated ratio. */
export interface IFinancialRatioValue {
    errorCode?: CalculationError;
    /** The calculated value of the ratio. May be null if the ratio could not be calculated. */
    value?: number | undefined;
}

/** Models imported financials. */
export class FinancialRecord implements IFinancialRecord {
    /** Additional metadata associated with the Financial Record that was added, by you, the API consumer. For example, you might associate the Financial Record with an identifier for a specific Loan Submission in your own system. */
    consumerMetadata!: ConsumerMetadata[];
    /** The time at which the financial data was imported. */
    dataAsOfTime!: string;
    accountingDataset!: Dataset;
    /** An identifier for the Financial Record. */
    id!: string;
    importStatus!: FinancialImportStatus;
    /** The end date for period-to-date financial data. Serialized using ISO 8601 date format "YYYY-MM-DD". */
    reportingEndDate!: string;
    /** Specifies whether the financial data was imported on-demand or via a schedule. */
    scheduled!: boolean;
    accountingDataImportOptions!: AccountingImportOptions;

    constructor(data?: IFinancialRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.consumerMetadata = [];
            this.accountingDataset = new Dataset();
            this.importStatus = new FinancialImportStatus();
            this.accountingDataImportOptions = new AccountingImportOptions();
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["consumerMetadata"])) {
                this.consumerMetadata = [] as any;
                for (let item of _data["consumerMetadata"])
                    this.consumerMetadata!.push(ConsumerMetadata.fromJS(item));
            }
            this.dataAsOfTime = _data["dataAsOfTime"];
            this.accountingDataset = _data["accountingDataset"] ? Dataset.fromJS(_data["accountingDataset"]) : new Dataset();
            this.id = _data["id"];
            this.importStatus = _data["importStatus"] ? FinancialImportStatus.fromJS(_data["importStatus"]) : new FinancialImportStatus();
            this.reportingEndDate = _data["reportingEndDate"];
            this.scheduled = _data["scheduled"];
            this.accountingDataImportOptions = _data["accountingDataImportOptions"] ? AccountingImportOptions.fromJS(_data["accountingDataImportOptions"]) : new AccountingImportOptions();
        }
    }

    static fromJS(data: any): FinancialRecord {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.consumerMetadata)) {
            data["consumerMetadata"] = [];
            for (let item of this.consumerMetadata)
                data["consumerMetadata"].push(item.toJSON());
        }
        data["dataAsOfTime"] = this.dataAsOfTime;
        data["accountingDataset"] = this.accountingDataset ? this.accountingDataset.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["importStatus"] = this.importStatus ? this.importStatus.toJSON() : <any>undefined;
        data["reportingEndDate"] = this.reportingEndDate;
        data["scheduled"] = this.scheduled;
        data["accountingDataImportOptions"] = this.accountingDataImportOptions ? this.accountingDataImportOptions.toJSON() : <any>undefined;
        return data; 
    }

    clone(): FinancialRecord {
        const json = this.toJSON();
        let result = new FinancialRecord();
        result.init(json);
        return result;
    }
}

/** Models imported financials. */
export interface IFinancialRecord {
    /** Additional metadata associated with the Financial Record that was added, by you, the API consumer. For example, you might associate the Financial Record with an identifier for a specific Loan Submission in your own system. */
    consumerMetadata: ConsumerMetadata[];
    /** The time at which the financial data was imported. */
    dataAsOfTime: string;
    accountingDataset: Dataset;
    /** An identifier for the Financial Record. */
    id: string;
    importStatus: FinancialImportStatus;
    /** The end date for period-to-date financial data. Serialized using ISO 8601 date format "YYYY-MM-DD". */
    reportingEndDate: string;
    /** Specifies whether the financial data was imported on-demand or via a schedule. */
    scheduled: boolean;
    accountingDataImportOptions: AccountingImportOptions;
}

/** Models a list of Financial Records. */
export class FinancialRecordList implements IFinancialRecordList {
    /** The set of Financial Records listed. */
    financialRecords!: FinancialRecord[];

    constructor(data?: IFinancialRecordList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.financialRecords = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["financialRecords"])) {
                this.financialRecords = [] as any;
                for (let item of _data["financialRecords"])
                    this.financialRecords!.push(FinancialRecord.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FinancialRecordList {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialRecordList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.financialRecords)) {
            data["financialRecords"] = [];
            for (let item of this.financialRecords)
                data["financialRecords"].push(item.toJSON());
        }
        return data; 
    }

    clone(): FinancialRecordList {
        const json = this.toJSON();
        let result = new FinancialRecordList();
        result.init(json);
        return result;
    }
}

/** Models a list of Financial Records. */
export interface IFinancialRecordList {
    /** The set of Financial Records listed. */
    financialRecords: FinancialRecord[];
}

/** A reference to a Financial Record by its id. */
export class FinancialRecordReference implements IFinancialRecordReference {
    /** An identifier for a Financial Record. */
    financialRecordId!: string;

    constructor(data?: IFinancialRecordReference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.financialRecordId = _data["financialRecordId"];
        }
    }

    static fromJS(data: any): FinancialRecordReference {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialRecordReference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["financialRecordId"] = this.financialRecordId;
        return data; 
    }

    clone(): FinancialRecordReference {
        const json = this.toJSON();
        let result = new FinancialRecordReference();
        result.init(json);
        return result;
    }
}

/** A reference to a Financial Record by its id. */
export interface IFinancialRecordReference {
    /** An identifier for a Financial Record. */
    financialRecordId: string;
}

/** Models a set of checks that were run against the financial data to verify accuracy, completeness, and reliability of that data. */
export class FinancialReview implements IFinancialReview {
    /** The checks that were run for the review of the financial data. */
    checks!: FinancialReviewCheck[];

    constructor(data?: IFinancialReview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.checks = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["checks"])) {
                this.checks = [] as any;
                for (let item of _data["checks"])
                    this.checks!.push(FinancialReviewCheck.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FinancialReview {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialReview();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.checks)) {
            data["checks"] = [];
            for (let item of this.checks)
                data["checks"].push(item.toJSON());
        }
        return data; 
    }

    clone(): FinancialReview {
        const json = this.toJSON();
        let result = new FinancialReview();
        result.init(json);
        return result;
    }
}

/** Models a set of checks that were run against the financial data to verify accuracy, completeness, and reliability of that data. */
export interface IFinancialReview {
    /** The checks that were run for the review of the financial data. */
    checks: FinancialReviewCheck[];
}

/** Models the outcome of a check that was executed against the financial data. */
export class FinancialReviewCheck implements IFinancialReviewCheck {
    /** An identifier for the check. */
    id!: string;
    /** A category assigned to the check. Refer to the documentation [here](https://developer.strongbox.link/guides.html#financial-reviews) to learn more. */
    category?: string | undefined;
    outcome!: FinancialReviewCheckOutcome;
    /** A description of the outcome of the check. May be null. */
    outcomeDescription?: string | undefined;
    /** If the check was run for a specific time period, the first date in that time period (inclusive), otherwise null. Serialized using "YYYY-MM-DD" format as defined by ISO 8601-1:2019. */
    fromDate?: string | undefined;
    /** If the check was run for a specific time period, the last date in that time period (inclusive), otherwise null. Serialized using "YYYY-MM-DD" format as defined by ISO 8601-1:2019. */
    toDate?: string | undefined;

    constructor(data?: IFinancialReviewCheck) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.category = _data["category"];
            this.outcome = _data["outcome"];
            this.outcomeDescription = _data["outcomeDescription"];
            this.fromDate = _data["fromDate"];
            this.toDate = _data["toDate"];
        }
    }

    static fromJS(data: any): FinancialReviewCheck {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialReviewCheck();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["category"] = this.category;
        data["outcome"] = this.outcome;
        data["outcomeDescription"] = this.outcomeDescription;
        data["fromDate"] = this.fromDate;
        data["toDate"] = this.toDate;
        return data; 
    }

    clone(): FinancialReviewCheck {
        const json = this.toJSON();
        let result = new FinancialReviewCheck();
        result.init(json);
        return result;
    }
}

/** Models the outcome of a check that was executed against the financial data. */
export interface IFinancialReviewCheck {
    /** An identifier for the check. */
    id: string;
    /** A category assigned to the check. Refer to the documentation [here](https://developer.strongbox.link/guides.html#financial-reviews) to learn more. */
    category?: string | undefined;
    outcome: FinancialReviewCheckOutcome;
    /** A description of the outcome of the check. May be null. */
    outcomeDescription?: string | undefined;
    /** If the check was run for a specific time period, the first date in that time period (inclusive), otherwise null. Serialized using "YYYY-MM-DD" format as defined by ISO 8601-1:2019. */
    fromDate?: string | undefined;
    /** If the check was run for a specific time period, the last date in that time period (inclusive), otherwise null. Serialized using "YYYY-MM-DD" format as defined by ISO 8601-1:2019. */
    toDate?: string | undefined;
}

/** Models possible outcomes for a financial review check. |Enum Value|Description| |--|--| |Inconclusive|No conclusion could be drawn or the check was not applicable.| |Pass|The check passed.| |Fail|The check failed.| */
export type FinancialReviewCheckOutcome = "Inconclusive" | "Pass" | "Fail";

/** A Horizontal Analysis of Financial Statement line items. */
export class FinancialStatementHorizontalAnalysis implements IFinancialStatementHorizontalAnalysis {
    /** Horiztontal Analysis comparative data by line item. */
    lineItems!: HorizontalAnalysisLineItem[];

    constructor(data?: IFinancialStatementHorizontalAnalysis) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.lineItems = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lineItems"])) {
                this.lineItems = [] as any;
                for (let item of _data["lineItems"])
                    this.lineItems!.push(HorizontalAnalysisLineItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FinancialStatementHorizontalAnalysis {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialStatementHorizontalAnalysis();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lineItems)) {
            data["lineItems"] = [];
            for (let item of this.lineItems)
                data["lineItems"].push(item.toJSON());
        }
        return data; 
    }

    clone(): FinancialStatementHorizontalAnalysis {
        const json = this.toJSON();
        let result = new FinancialStatementHorizontalAnalysis();
        result.init(json);
        return result;
    }
}

/** A Horizontal Analysis of Financial Statement line items. */
export interface IFinancialStatementHorizontalAnalysis {
    /** Horiztontal Analysis comparative data by line item. */
    lineItems: HorizontalAnalysisLineItem[];
}

/** Used to configure the financial statements that are collected from the accounting system. */
export class FinancialStatementImportOptions implements IFinancialStatementImportOptions {
    basisOfAccountingPreference?: BasisOfAccountingPreference;
    reportingPeriod?: ImportReportingPeriod;
    /** A natural number greater than or equal to zero used to specify the total number of months, quarters, or years for which financial data is desired. The month-to-date, quarter-to-date, or year-to-date period is included in this count. For example, setting 'reportingPeriod' to 'FiscalYears' and 'numberOfReportingPeriods' to 3 should be interpreted as '2 full fiscal years and fiscal YTD'. Setting 'numberOfPeriods' to zero disables data collection. */
    numberOfPeriods!: number;

    constructor(data?: IFinancialStatementImportOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.basisOfAccountingPreference = _data["basisOfAccountingPreference"];
            this.reportingPeriod = _data["reportingPeriod"];
            this.numberOfPeriods = _data["numberOfPeriods"];
        }
    }

    static fromJS(data: any): FinancialStatementImportOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialStatementImportOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["basisOfAccountingPreference"] = this.basisOfAccountingPreference;
        data["reportingPeriod"] = this.reportingPeriod;
        data["numberOfPeriods"] = this.numberOfPeriods;
        return data; 
    }

    clone(): FinancialStatementImportOptions {
        const json = this.toJSON();
        let result = new FinancialStatementImportOptions();
        result.init(json);
        return result;
    }
}

/** Used to configure the financial statements that are collected from the accounting system. */
export interface IFinancialStatementImportOptions {
    basisOfAccountingPreference?: BasisOfAccountingPreference;
    reportingPeriod?: ImportReportingPeriod;
    /** A natural number greater than or equal to zero used to specify the total number of months, quarters, or years for which financial data is desired. The month-to-date, quarter-to-date, or year-to-date period is included in this count. For example, setting 'reportingPeriod' to 'FiscalYears' and 'numberOfReportingPeriods' to 3 should be interpreted as '2 full fiscal years and fiscal YTD'. Setting 'numberOfPeriods' to zero disables data collection. */
    numberOfPeriods: number;
}

/** Models information about a Financial Workbook that can be downloaded. */
export class FinancialWorkbook implements IFinancialWorkbook {
    /** An identifier for the Financial Workbook variant. */
    variantId!: string;
    /** The filename associated with the Financial Workbook. */
    filename!: string;
    /** The time at which the Financial Workbook was created. */
    creationTime!: string;
    /** A set of tags associated with the workbook. Examples are 'Customer Copy', 'Accrual Basis', and 'Cash Basis'. */
    tags?: string[] | undefined;

    constructor(data?: IFinancialWorkbook) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.variantId = _data["variantId"];
            this.filename = _data["filename"];
            this.creationTime = _data["creationTime"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): FinancialWorkbook {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialWorkbook();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["variantId"] = this.variantId;
        data["filename"] = this.filename;
        data["creationTime"] = this.creationTime;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data; 
    }

    clone(): FinancialWorkbook {
        const json = this.toJSON();
        let result = new FinancialWorkbook();
        result.init(json);
        return result;
    }
}

/** Models information about a Financial Workbook that can be downloaded. */
export interface IFinancialWorkbook {
    /** An identifier for the Financial Workbook variant. */
    variantId: string;
    /** The filename associated with the Financial Workbook. */
    filename: string;
    /** The time at which the Financial Workbook was created. */
    creationTime: string;
    /** A set of tags associated with the workbook. Examples are 'Customer Copy', 'Accrual Basis', and 'Cash Basis'. */
    tags?: string[] | undefined;
}

/** Models a list of Financial Workbooks. */
export class FinancialWorkbooksList implements IFinancialWorkbooksList {
    /** The set of Financial Workbooks being listed. */
    workbooks!: FinancialWorkbook[];

    constructor(data?: IFinancialWorkbooksList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.workbooks = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["workbooks"])) {
                this.workbooks = [] as any;
                for (let item of _data["workbooks"])
                    this.workbooks!.push(FinancialWorkbook.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FinancialWorkbooksList {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialWorkbooksList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.workbooks)) {
            data["workbooks"] = [];
            for (let item of this.workbooks)
                data["workbooks"].push(item.toJSON());
        }
        return data; 
    }

    clone(): FinancialWorkbooksList {
        const json = this.toJSON();
        let result = new FinancialWorkbooksList();
        result.init(json);
        return result;
    }
}

/** Models a list of Financial Workbooks. */
export interface IFinancialWorkbooksList {
    /** The set of Financial Workbooks being listed. */
    workbooks: FinancialWorkbook[];
}

/** This response may be used when returning a 403 HTTP status code. */
export class Forbidden implements IForbidden {
    /** A description of why the request was denied for troubleshooting purposes.
May be null or omitted. */
    description?: string | undefined;

    constructor(data?: IForbidden) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): Forbidden {
        data = typeof data === 'object' ? data : {};
        let result = new Forbidden();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        return data; 
    }

    clone(): Forbidden {
        const json = this.toJSON();
        let result = new Forbidden();
        result.init(json);
        return result;
    }
}

/** This response may be used when returning a 403 HTTP status code. */
export interface IForbidden {
    /** A description of why the request was denied for troubleshooting purposes.
May be null or omitted. */
    description?: string | undefined;
}

/** Models a Horizontal Analysis. */
export class HorizontalAnalysis implements IHorizontalAnalysis {
    baselinePeriodType!: BaselinePeriodType;
    /** Information about the set of reporting periods included in the Horizontal Analysis, including the baseline period that each is being compared to. */
    reportingPeriods!: ReportingPeriodComparison[];
    /** The set of metrics that were evaluated for the Horizontal Analysis. */
    metrics!: HorizontalAnalysisMetric[];

    constructor(data?: IHorizontalAnalysis) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.reportingPeriods = [];
            this.metrics = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baselinePeriodType = _data["baselinePeriodType"];
            if (Array.isArray(_data["reportingPeriods"])) {
                this.reportingPeriods = [] as any;
                for (let item of _data["reportingPeriods"])
                    this.reportingPeriods!.push(ReportingPeriodComparison.fromJS(item));
            }
            if (Array.isArray(_data["metrics"])) {
                this.metrics = [] as any;
                for (let item of _data["metrics"])
                    this.metrics!.push(HorizontalAnalysisMetric.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HorizontalAnalysis {
        data = typeof data === 'object' ? data : {};
        let result = new HorizontalAnalysis();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baselinePeriodType"] = this.baselinePeriodType;
        if (Array.isArray(this.reportingPeriods)) {
            data["reportingPeriods"] = [];
            for (let item of this.reportingPeriods)
                data["reportingPeriods"].push(item.toJSON());
        }
        if (Array.isArray(this.metrics)) {
            data["metrics"] = [];
            for (let item of this.metrics)
                data["metrics"].push(item.toJSON());
        }
        return data; 
    }

    clone(): HorizontalAnalysis {
        const json = this.toJSON();
        let result = new HorizontalAnalysis();
        result.init(json);
        return result;
    }
}

/** Models a Horizontal Analysis. */
export interface IHorizontalAnalysis {
    baselinePeriodType: BaselinePeriodType;
    /** Information about the set of reporting periods included in the Horizontal Analysis, including the baseline period that each is being compared to. */
    reportingPeriods: ReportingPeriodComparison[];
    /** The set of metrics that were evaluated for the Horizontal Analysis. */
    metrics: HorizontalAnalysisMetric[];
}

/** Comparative data representing a Horizontal Analysis of a single Financial Ratio. */
export class HorizontalAnalysisFinancialRatio implements IHorizontalAnalysisFinancialRatio {
    /** A unique identifier for the financial ratio. */
    id!: string;
    /** A friendly name for the ratio. */
    displayName!: string;
    /** A category assigned to the ratio. */
    category?: string | undefined;
    comparativeData!: HorizontalComparison[];

    constructor(data?: IHorizontalAnalysisFinancialRatio) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.comparativeData = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.category = _data["category"];
            if (Array.isArray(_data["comparativeData"])) {
                this.comparativeData = [] as any;
                for (let item of _data["comparativeData"])
                    this.comparativeData!.push(HorizontalComparison.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HorizontalAnalysisFinancialRatio {
        data = typeof data === 'object' ? data : {};
        let result = new HorizontalAnalysisFinancialRatio();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["category"] = this.category;
        if (Array.isArray(this.comparativeData)) {
            data["comparativeData"] = [];
            for (let item of this.comparativeData)
                data["comparativeData"].push(item.toJSON());
        }
        return data; 
    }

    clone(): HorizontalAnalysisFinancialRatio {
        const json = this.toJSON();
        let result = new HorizontalAnalysisFinancialRatio();
        result.init(json);
        return result;
    }
}

/** Comparative data representing a Horizontal Analysis of a single Financial Ratio. */
export interface IHorizontalAnalysisFinancialRatio {
    /** A unique identifier for the financial ratio. */
    id: string;
    /** A friendly name for the ratio. */
    displayName: string;
    /** A category assigned to the ratio. */
    category?: string | undefined;
    comparativeData: HorizontalComparison[];
}

/** Defines possible metrics for which a Horizontal Analysis can be done. |Enum Value|Description| |--|--| |IncomeStatementLineItem|The metric represents the amounts reported by a line item on the Income Statement.| |BalanceSheetLineItem|The metric represents the amounts reported by a line item on the Balance Sheet.| |FinancialRatio|The metric represents a Finacial Ratio calculated from figures appearing on the Financial Statements.| */
export type HorizontalAnalysisInputMetricType = "IncomeStatementLineItem" | "BalanceSheetLineItem" | "FinancialRatio";

/** Models a Horizontal Analysis. */
export class HorizontalAnalysisLegacy implements IHorizontalAnalysisLegacy {
    baselinePeriodType!: BaselinePeriodType;
    /** Information about the set of reporting periods included in the horizontal analysis, including the baseline period that each is being compared to. */
    reportingPeriods!: ReportingPeriodComparison[];
    incomeStatement!: FinancialStatementHorizontalAnalysis;
    balanceSheet!: FinancialStatementHorizontalAnalysis;
    financialRatios!: FinancialRatiosHorizontalAnalysis;

    constructor(data?: IHorizontalAnalysisLegacy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.reportingPeriods = [];
            this.incomeStatement = new FinancialStatementHorizontalAnalysis();
            this.balanceSheet = new FinancialStatementHorizontalAnalysis();
            this.financialRatios = new FinancialRatiosHorizontalAnalysis();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baselinePeriodType = _data["baselinePeriodType"];
            if (Array.isArray(_data["reportingPeriods"])) {
                this.reportingPeriods = [] as any;
                for (let item of _data["reportingPeriods"])
                    this.reportingPeriods!.push(ReportingPeriodComparison.fromJS(item));
            }
            this.incomeStatement = _data["incomeStatement"] ? FinancialStatementHorizontalAnalysis.fromJS(_data["incomeStatement"]) : new FinancialStatementHorizontalAnalysis();
            this.balanceSheet = _data["balanceSheet"] ? FinancialStatementHorizontalAnalysis.fromJS(_data["balanceSheet"]) : new FinancialStatementHorizontalAnalysis();
            this.financialRatios = _data["financialRatios"] ? FinancialRatiosHorizontalAnalysis.fromJS(_data["financialRatios"]) : new FinancialRatiosHorizontalAnalysis();
        }
    }

    static fromJS(data: any): HorizontalAnalysisLegacy {
        data = typeof data === 'object' ? data : {};
        let result = new HorizontalAnalysisLegacy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baselinePeriodType"] = this.baselinePeriodType;
        if (Array.isArray(this.reportingPeriods)) {
            data["reportingPeriods"] = [];
            for (let item of this.reportingPeriods)
                data["reportingPeriods"].push(item.toJSON());
        }
        data["incomeStatement"] = this.incomeStatement ? this.incomeStatement.toJSON() : <any>undefined;
        data["balanceSheet"] = this.balanceSheet ? this.balanceSheet.toJSON() : <any>undefined;
        data["financialRatios"] = this.financialRatios ? this.financialRatios.toJSON() : <any>undefined;
        return data; 
    }

    clone(): HorizontalAnalysisLegacy {
        const json = this.toJSON();
        let result = new HorizontalAnalysisLegacy();
        result.init(json);
        return result;
    }
}

/** Models a Horizontal Analysis. */
export interface IHorizontalAnalysisLegacy {
    baselinePeriodType: BaselinePeriodType;
    /** Information about the set of reporting periods included in the horizontal analysis, including the baseline period that each is being compared to. */
    reportingPeriods: ReportingPeriodComparison[];
    incomeStatement: FinancialStatementHorizontalAnalysis;
    balanceSheet: FinancialStatementHorizontalAnalysis;
    financialRatios: FinancialRatiosHorizontalAnalysis;
}

/** Comparative data representing a Horizontal Analysis of a single line item appearing on a financial statement. */
export class HorizontalAnalysisLineItem implements IHorizontalAnalysisLineItem {
    /** An identifier for the line item. */
    id!: string;
    accountRef?: AccountReference;
    /** The line item caption, which is label for the line item as it would appear on the statement. */
    caption!: string;
    lineItemType!: LineItemType;
    /** The results of comparing this line item to value reported in the baseline period. */
    comparativeData!: HorizontalComparison[];
    /** Each line item may contain a set of subtotal lines. */
    subtotals!: HorizontalAnalysisLineItem[];

    constructor(data?: IHorizontalAnalysisLineItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.comparativeData = [];
            this.subtotals = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.accountRef = _data["accountRef"] ? AccountReference.fromJS(_data["accountRef"]) : <any>undefined;
            this.caption = _data["caption"];
            this.lineItemType = _data["lineItemType"];
            if (Array.isArray(_data["comparativeData"])) {
                this.comparativeData = [] as any;
                for (let item of _data["comparativeData"])
                    this.comparativeData!.push(HorizontalComparison.fromJS(item));
            }
            if (Array.isArray(_data["subtotals"])) {
                this.subtotals = [] as any;
                for (let item of _data["subtotals"])
                    this.subtotals!.push(HorizontalAnalysisLineItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HorizontalAnalysisLineItem {
        data = typeof data === 'object' ? data : {};
        let result = new HorizontalAnalysisLineItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["accountRef"] = this.accountRef ? this.accountRef.toJSON() : <any>undefined;
        data["caption"] = this.caption;
        data["lineItemType"] = this.lineItemType;
        if (Array.isArray(this.comparativeData)) {
            data["comparativeData"] = [];
            for (let item of this.comparativeData)
                data["comparativeData"].push(item.toJSON());
        }
        if (Array.isArray(this.subtotals)) {
            data["subtotals"] = [];
            for (let item of this.subtotals)
                data["subtotals"].push(item.toJSON());
        }
        return data; 
    }

    clone(): HorizontalAnalysisLineItem {
        const json = this.toJSON();
        let result = new HorizontalAnalysisLineItem();
        result.init(json);
        return result;
    }
}

/** Comparative data representing a Horizontal Analysis of a single line item appearing on a financial statement. */
export interface IHorizontalAnalysisLineItem {
    /** An identifier for the line item. */
    id: string;
    accountRef?: AccountReference;
    /** The line item caption, which is label for the line item as it would appear on the statement. */
    caption: string;
    lineItemType: LineItemType;
    /** The results of comparing this line item to value reported in the baseline period. */
    comparativeData: HorizontalComparison[];
    /** Each line item may contain a set of subtotal lines. */
    subtotals: HorizontalAnalysisLineItem[];
}

/** Models Horizontal Analysis data calculated for a specific financial statement metric. */
export class HorizontalAnalysisMetric implements IHorizontalAnalysisMetric {
    /** An identifier for the financial statement metric. */
    inputMetricId!: string;
    inputMetricType!: HorizontalAnalysisInputMetricType;
    /** Horizontal comparisons for each reporting period compared to the baseline period. */
    comparativeData!: HorizontalComparison[];

    constructor(data?: IHorizontalAnalysisMetric) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.comparativeData = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inputMetricId = _data["inputMetricId"];
            this.inputMetricType = _data["inputMetricType"];
            if (Array.isArray(_data["comparativeData"])) {
                this.comparativeData = [] as any;
                for (let item of _data["comparativeData"])
                    this.comparativeData!.push(HorizontalComparison.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HorizontalAnalysisMetric {
        data = typeof data === 'object' ? data : {};
        let result = new HorizontalAnalysisMetric();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inputMetricId"] = this.inputMetricId;
        data["inputMetricType"] = this.inputMetricType;
        if (Array.isArray(this.comparativeData)) {
            data["comparativeData"] = [];
            for (let item of this.comparativeData)
                data["comparativeData"].push(item.toJSON());
        }
        return data; 
    }

    clone(): HorizontalAnalysisMetric {
        const json = this.toJSON();
        let result = new HorizontalAnalysisMetric();
        result.init(json);
        return result;
    }
}

/** Models Horizontal Analysis data calculated for a specific financial statement metric. */
export interface IHorizontalAnalysisMetric {
    /** An identifier for the financial statement metric. */
    inputMetricId: string;
    inputMetricType: HorizontalAnalysisInputMetricType;
    /** Horizontal comparisons for each reporting period compared to the baseline period. */
    comparativeData: HorizontalComparison[];
}

/** Models a comparison between a past and present value calculated as part of a horizontal analysis. */
export class HorizontalComparison implements IHorizontalComparison {
    /** The current value of the metric being compared to the past value. */
    currentValue?: number | undefined;
    /** The `currentValue` is compared to the `pastValue`. */
    pastValue?: number | undefined;
    /** The absolute change measured between the past and current value (`currentValue − pastValue`). */
    absoluteChange?: number | undefined;
    percentChange!: PercentageValue;

    constructor(data?: IHorizontalComparison) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.percentChange = new PercentageValue();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentValue = _data["currentValue"];
            this.pastValue = _data["pastValue"];
            this.absoluteChange = _data["absoluteChange"];
            this.percentChange = _data["percentChange"] ? PercentageValue.fromJS(_data["percentChange"]) : new PercentageValue();
        }
    }

    static fromJS(data: any): HorizontalComparison {
        data = typeof data === 'object' ? data : {};
        let result = new HorizontalComparison();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentValue"] = this.currentValue;
        data["pastValue"] = this.pastValue;
        data["absoluteChange"] = this.absoluteChange;
        data["percentChange"] = this.percentChange ? this.percentChange.toJSON() : <any>undefined;
        return data; 
    }

    clone(): HorizontalComparison {
        const json = this.toJSON();
        let result = new HorizontalComparison();
        result.init(json);
        return result;
    }
}

/** Models a comparison between a past and present value calculated as part of a horizontal analysis. */
export interface IHorizontalComparison {
    /** The current value of the metric being compared to the past value. */
    currentValue?: number | undefined;
    /** The `currentValue` is compared to the `pastValue`. */
    pastValue?: number | undefined;
    /** The absolute change measured between the past and current value (`currentValue − pastValue`). */
    absoluteChange?: number | undefined;
    percentChange: PercentageValue;
}

/** Models an identifier. */
export class Identifier implements IIdentifier {
    /** A label for the identifier to better understand its meaning. Possible values include, but are not limited to; ABN, ACN, TFN, EIN, WPN, ResaleNumber, SSN. */
    label!: string;
    /** The value for the identifier without any implied formatting or validation. */
    value!: string;

    constructor(data?: IIdentifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Identifier {
        data = typeof data === 'object' ? data : {};
        let result = new Identifier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data; 
    }

    clone(): Identifier {
        const json = this.toJSON();
        let result = new Identifier();
        result.init(json);
        return result;
    }
}

/** Models an identifier. */
export interface IIdentifier {
    /** A label for the identifier to better understand its meaning. Possible values include, but are not limited to; ABN, ACN, TFN, EIN, WPN, ResaleNumber, SSN. */
    label: string;
    /** The value for the identifier without any implied formatting or validation. */
    value: string;
}

/** Specifies the time period for which accounting and other financial data is prepared. |Enum Value|Description| |--|--| |Months|The reporting period is monthly.| |FiscalQuarters|The reporting period is quarterly; aligned to the fiscal year for the accounting entity.| |FiscalYears|The reporting period is annual; aligned to the fiscal year for the accounting entity.| */
export type ImportReportingPeriod = "Months" | "FiscalQuarters" | "FiscalYears";

/** Models options for selecting the base figures to use when running a vertical analysis against the Income Statement. |Enum Value|Description| |--|--| |NetSales|All line items are compared against Total Net Sales.| |NetIncome|All line items are compared against Net Income.| */
export type IncomeStatementBaseFigures = "NetSales" | "NetIncome";

/** A Vertical Analysis of Income Statement line items. */
export class IncomeStatementVerticalAnalysis implements IIncomeStatementVerticalAnalysis {
    baseFigures!: IncomeStatementBaseFigures;
    /** Vertical Analysis comparative data by line item. */
    lineItems!: VerticalAnalysisLineItem[];

    constructor(data?: IIncomeStatementVerticalAnalysis) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.lineItems = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baseFigures = _data["baseFigures"];
            if (Array.isArray(_data["lineItems"])) {
                this.lineItems = [] as any;
                for (let item of _data["lineItems"])
                    this.lineItems!.push(VerticalAnalysisLineItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IncomeStatementVerticalAnalysis {
        data = typeof data === 'object' ? data : {};
        let result = new IncomeStatementVerticalAnalysis();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseFigures"] = this.baseFigures;
        if (Array.isArray(this.lineItems)) {
            data["lineItems"] = [];
            for (let item of this.lineItems)
                data["lineItems"].push(item.toJSON());
        }
        return data; 
    }

    clone(): IncomeStatementVerticalAnalysis {
        const json = this.toJSON();
        let result = new IncomeStatementVerticalAnalysis();
        result.init(json);
        return result;
    }
}

/** A Vertical Analysis of Income Statement line items. */
export interface IIncomeStatementVerticalAnalysis {
    baseFigures: IncomeStatementBaseFigures;
    /** Vertical Analysis comparative data by line item. */
    lineItems: VerticalAnalysisLineItem[];
}

/** Models parameters to setup an Organization as it appears in the Strongbox Web Portal. */
export class InitializeOrganizationParameters implements IInitializeOrganizationParameters {
    /** A display name to be used for the Organization as it appears in the Strongbox Web Portal.
The maximum length of the display name is 256 characters. */
    displayName!: string;

    constructor(data?: IInitializeOrganizationParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): InitializeOrganizationParameters {
        data = typeof data === 'object' ? data : {};
        let result = new InitializeOrganizationParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        return data; 
    }

    clone(): InitializeOrganizationParameters {
        const json = this.toJSON();
        let result = new InitializeOrganizationParameters();
        result.init(json);
        return result;
    }
}

/** Models parameters to setup an Organization as it appears in the Strongbox Web Portal. */
export interface IInitializeOrganizationParameters {
    /** A display name to be used for the Organization as it appears in the Strongbox Web Portal.
The maximum length of the display name is 256 characters. */
    displayName: string;
}

/** Models a line item appearing in a financial statement. */
export class LineItem implements ILineItem {
    accountRef?: AccountReference;
    /** A label for for the line item. For example, "Assets", "Total Current Assets", "Gross Profit", or "Accounts Receivable". */
    caption!: string;
    /** The reported monetary amounts associated with the line item. These figures correspond to the reporting periods in the financial statement column headers. If the type of line item is None, then there will be no column data. */
    columnData!: number[];
    /** An optional description of the line item. Can be presented as tooltip depending on the mechanism being used to present the financial statement. May be null. */
    description?: string | undefined;
    /** An identifier for the line item which is unique within the scope of the financial statement. */
    id!: string;
    /** For presentation purposes, this represents the indentation level of the line item. */
    indentationLevel!: number;
    /** The style of the line item. */
    styleClasses!: StyleClasses[];

    constructor(data?: ILineItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.columnData = [];
            this.styleClasses = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountRef = _data["accountRef"] ? AccountReference.fromJS(_data["accountRef"]) : <any>undefined;
            this.caption = _data["caption"];
            if (Array.isArray(_data["columnData"])) {
                this.columnData = [] as any;
                for (let item of _data["columnData"])
                    this.columnData!.push(item);
            }
            this.description = _data["description"];
            this.id = _data["id"];
            this.indentationLevel = _data["indentationLevel"];
            if (Array.isArray(_data["styleClasses"])) {
                this.styleClasses = [] as any;
                for (let item of _data["styleClasses"])
                    this.styleClasses!.push(item);
            }
        }
    }

    static fromJS(data: any): LineItem {
        data = typeof data === 'object' ? data : {};
        let result = new LineItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountRef"] = this.accountRef ? this.accountRef.toJSON() : <any>undefined;
        data["caption"] = this.caption;
        if (Array.isArray(this.columnData)) {
            data["columnData"] = [];
            for (let item of this.columnData)
                data["columnData"].push(item);
        }
        data["description"] = this.description;
        data["id"] = this.id;
        data["indentationLevel"] = this.indentationLevel;
        if (Array.isArray(this.styleClasses)) {
            data["styleClasses"] = [];
            for (let item of this.styleClasses)
                data["styleClasses"].push(item);
        }
        return data; 
    }

    clone(): LineItem {
        const json = this.toJSON();
        let result = new LineItem();
        result.init(json);
        return result;
    }
}

/** Models a line item appearing in a financial statement. */
export interface ILineItem {
    accountRef?: AccountReference;
    /** A label for for the line item. For example, "Assets", "Total Current Assets", "Gross Profit", or "Accounts Receivable". */
    caption: string;
    /** The reported monetary amounts associated with the line item. These figures correspond to the reporting periods in the financial statement column headers. If the type of line item is None, then there will be no column data. */
    columnData: number[];
    /** An optional description of the line item. Can be presented as tooltip depending on the mechanism being used to present the financial statement. May be null. */
    description?: string | undefined;
    /** An identifier for the line item which is unique within the scope of the financial statement. */
    id: string;
    /** For presentation purposes, this represents the indentation level of the line item. */
    indentationLevel: number;
    /** The style of the line item. */
    styleClasses: StyleClasses[];
}

/** Models the types of line items appearing in financial statement analysis responses. |Enum Value|Description| |--|--| |SourceCoA|The line item represents an account from the company's chart of accounts.| |SourceCoASubtotal|The line item represents a subtotal of accounts in the company's chart of accounts.| |ClassificationSubtotal|The line item represents a subtotal for an account classification in the taxonomy that the company's chart of accounts was mapped to.| */
export type LineItemType = "SourceCoA" | "SourceCoASubtotal" | "ClassificationSubtotal";

/** This response may be used when returning a 404 HTTP status code. */
export class NotFound implements INotFound {
    /** A message describing which resource could not be found for troubleshooting purposes. */
    description?: string | undefined;

    constructor(data?: INotFound) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): NotFound {
        data = typeof data === 'object' ? data : {};
        let result = new NotFound();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        return data; 
    }

    clone(): NotFound {
        const json = this.toJSON();
        let result = new NotFound();
        result.init(json);
        return result;
    }
}

/** This response may be used when returning a 404 HTTP status code. */
export interface INotFound {
    /** A message describing which resource could not be found for troubleshooting purposes. */
    description?: string | undefined;
}

/** Models the name of an organization. */
export class OrganizationName implements IOrganizationName {
    /** A set of tags providing additional information about the name. */
    tags!: OrganizationNameTag[];
    /** The name value with no implied formatting or validation. */
    value!: string;

    constructor(data?: IOrganizationName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.tags = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): OrganizationName {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["value"] = this.value;
        return data; 
    }

    clone(): OrganizationName {
        const json = this.toJSON();
        let result = new OrganizationName();
        result.init(json);
        return result;
    }
}

/** Models the name of an organization. */
export interface IOrganizationName {
    /** A set of tags providing additional information about the name. */
    tags: OrganizationNameTag[];
    /** The name value with no implied formatting or validation. */
    value: string;
}

/** Defines a set of tags providing additional information about a Name. |Enum Value|Description| |--|--| |Legal|The name is the legal name for the Organization.| |Dba|The name is used as a trade name. Short for "Doing Business As".| */
export type OrganizationNameTag = "Legal" | "Dba";

/** Models additional contact information. */
export class OtherContactMethod implements IOtherContactMethod {
    /** A name or description of the contact associated with the contact info. For example, "John Doe" or "Customer Support". */
    contact?: string | undefined;
    /** A friendly description of the contact method. For example 'Skype Account'. */
    description!: string;
    /** A value for the contact method without any implied formatting or validation. */
    value!: string;

    constructor(data?: IOtherContactMethod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contact = _data["contact"];
            this.description = _data["description"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): OtherContactMethod {
        data = typeof data === 'object' ? data : {};
        let result = new OtherContactMethod();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contact"] = this.contact;
        data["description"] = this.description;
        data["value"] = this.value;
        return data; 
    }

    clone(): OtherContactMethod {
        const json = this.toJSON();
        let result = new OtherContactMethod();
        result.init(json);
        return result;
    }
}

/** Models additional contact information. */
export interface IOtherContactMethod {
    /** A name or description of the contact associated with the contact info. For example, "John Doe" or "Customer Support". */
    contact?: string | undefined;
    /** A friendly description of the contact method. For example 'Skype Account'. */
    description: string;
    /** A value for the contact method without any implied formatting or validation. */
    value: string;
}

/** Outstanding Payables by reporting period. */
export class OutstandingPayablesHistory implements IOutstandingPayablesHistory {
    /** Outstanding receivables or payables calculated for each reporting period. */
    history!: OutstandingReceivableOrPayableList[];

    constructor(data?: IOutstandingPayablesHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.history = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["history"])) {
                this.history = [] as any;
                for (let item of _data["history"])
                    this.history!.push(OutstandingReceivableOrPayableList.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OutstandingPayablesHistory {
        data = typeof data === 'object' ? data : {};
        let result = new OutstandingPayablesHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.history)) {
            data["history"] = [];
            for (let item of this.history)
                data["history"].push(item.toJSON());
        }
        return data; 
    }

    clone(): OutstandingPayablesHistory {
        const json = this.toJSON();
        let result = new OutstandingPayablesHistory();
        result.init(json);
        return result;
    }
}

/** Outstanding Payables by reporting period. */
export interface IOutstandingPayablesHistory {
    /** Outstanding receivables or payables calculated for each reporting period. */
    history: OutstandingReceivableOrPayableList[];
}

/** Models an outstanding receivable or payable transaction including invoices, receipts, credit notes, and refunds. */
export class OutstandingReceivableOrPayable implements IOutstandingReceivableOrPayable {
    amountOutstanding!: DoubleEntryAmount;
    businessRelationship?: BusinessRelationship;
    /** A positive or negative integer representing the number of days before or after the due date relative to the financial reporting date. For example, the age one day before the due date is -1 and the age one day after the due date is 1. If a due date is not specified then 'transactionDate' is treated as the due date. */
    daysFromDueDate!: number;
    /** A positive integer representing the number of days since the transaction was created as of the financial reporting date. For example, the age one day after the transaction date is 1. */
    daysFromTransactionDate!: number;
    debtDescriptor!: DebtDescriptor;
    /** The date at which time an invoice is due, if a due date is specified. */
    dueDate?: string | undefined;
    transactionAmount!: DoubleEntryAmount;
    /** The date on which the transaction occured, for financial reporting purposes. */
    transactionDate!: string;
    /** An identifier for the transaction. */
    transactionId!: string;
    /** The type of the transaction, as specified by the datasource. Some examples are: "Invoice", "Credit Memo", and "Credit Card Payment". */
    transactionType?: string | undefined;
    /** A document number assigned to the transaction. Usually alpha-numeric and sequenced by the accounting system automatically. Examples are 'Invoice #' and 'Credit Memo #' found in QuickBooks or Xero. */
    docNo?: string | undefined;
    /** An secondary reference number assigned to the transaction. Typically alpha-numeric and user-defined. */
    refNo?: string | undefined;

    constructor(data?: IOutstandingReceivableOrPayable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.amountOutstanding = new DoubleEntryAmount();
            this.transactionAmount = new DoubleEntryAmount();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amountOutstanding = _data["amountOutstanding"] ? DoubleEntryAmount.fromJS(_data["amountOutstanding"]) : new DoubleEntryAmount();
            this.businessRelationship = _data["businessRelationship"] ? BusinessRelationship.fromJS(_data["businessRelationship"]) : <any>undefined;
            this.daysFromDueDate = _data["daysFromDueDate"];
            this.daysFromTransactionDate = _data["daysFromTransactionDate"];
            this.debtDescriptor = _data["debtDescriptor"];
            this.dueDate = _data["dueDate"];
            this.transactionAmount = _data["transactionAmount"] ? DoubleEntryAmount.fromJS(_data["transactionAmount"]) : new DoubleEntryAmount();
            this.transactionDate = _data["transactionDate"];
            this.transactionId = _data["transactionId"];
            this.transactionType = _data["transactionType"];
            this.docNo = _data["docNo"];
            this.refNo = _data["refNo"];
        }
    }

    static fromJS(data: any): OutstandingReceivableOrPayable {
        data = typeof data === 'object' ? data : {};
        let result = new OutstandingReceivableOrPayable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amountOutstanding"] = this.amountOutstanding ? this.amountOutstanding.toJSON() : <any>undefined;
        data["businessRelationship"] = this.businessRelationship ? this.businessRelationship.toJSON() : <any>undefined;
        data["daysFromDueDate"] = this.daysFromDueDate;
        data["daysFromTransactionDate"] = this.daysFromTransactionDate;
        data["debtDescriptor"] = this.debtDescriptor;
        data["dueDate"] = this.dueDate;
        data["transactionAmount"] = this.transactionAmount ? this.transactionAmount.toJSON() : <any>undefined;
        data["transactionDate"] = this.transactionDate;
        data["transactionId"] = this.transactionId;
        data["transactionType"] = this.transactionType;
        data["docNo"] = this.docNo;
        data["refNo"] = this.refNo;
        return data; 
    }

    clone(): OutstandingReceivableOrPayable {
        const json = this.toJSON();
        let result = new OutstandingReceivableOrPayable();
        result.init(json);
        return result;
    }
}

/** Models an outstanding receivable or payable transaction including invoices, receipts, credit notes, and refunds. */
export interface IOutstandingReceivableOrPayable {
    amountOutstanding: DoubleEntryAmount;
    businessRelationship?: BusinessRelationship;
    /** A positive or negative integer representing the number of days before or after the due date relative to the financial reporting date. For example, the age one day before the due date is -1 and the age one day after the due date is 1. If a due date is not specified then 'transactionDate' is treated as the due date. */
    daysFromDueDate: number;
    /** A positive integer representing the number of days since the transaction was created as of the financial reporting date. For example, the age one day after the transaction date is 1. */
    daysFromTransactionDate: number;
    debtDescriptor: DebtDescriptor;
    /** The date at which time an invoice is due, if a due date is specified. */
    dueDate?: string | undefined;
    transactionAmount: DoubleEntryAmount;
    /** The date on which the transaction occured, for financial reporting purposes. */
    transactionDate: string;
    /** An identifier for the transaction. */
    transactionId: string;
    /** The type of the transaction, as specified by the datasource. Some examples are: "Invoice", "Credit Memo", and "Credit Card Payment". */
    transactionType?: string | undefined;
    /** A document number assigned to the transaction. Usually alpha-numeric and sequenced by the accounting system automatically. Examples are 'Invoice #' and 'Credit Memo #' found in QuickBooks or Xero. */
    docNo?: string | undefined;
    /** An secondary reference number assigned to the transaction. Typically alpha-numeric and user-defined. */
    refNo?: string | undefined;
}

/** Models a set of outstanding receivable or payable transactions. */
export class OutstandingReceivableOrPayableList implements IOutstandingReceivableOrPayableList {
    /** The date corresponding at which outstanding receivables or payables data was calculated. */
    asOf!: string;
    /** The set of outstanding receivable or payable transactions. */
    transactions!: OutstandingReceivableOrPayable[];

    constructor(data?: IOutstandingReceivableOrPayableList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.transactions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.asOf = _data["asOf"];
            if (Array.isArray(_data["transactions"])) {
                this.transactions = [] as any;
                for (let item of _data["transactions"])
                    this.transactions!.push(OutstandingReceivableOrPayable.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OutstandingReceivableOrPayableList {
        data = typeof data === 'object' ? data : {};
        let result = new OutstandingReceivableOrPayableList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["asOf"] = this.asOf;
        if (Array.isArray(this.transactions)) {
            data["transactions"] = [];
            for (let item of this.transactions)
                data["transactions"].push(item.toJSON());
        }
        return data; 
    }

    clone(): OutstandingReceivableOrPayableList {
        const json = this.toJSON();
        let result = new OutstandingReceivableOrPayableList();
        result.init(json);
        return result;
    }
}

/** Models a set of outstanding receivable or payable transactions. */
export interface IOutstandingReceivableOrPayableList {
    /** The date corresponding at which outstanding receivables or payables data was calculated. */
    asOf: string;
    /** The set of outstanding receivable or payable transactions. */
    transactions: OutstandingReceivableOrPayable[];
}

/** Outstanding Receivables by reporting period. */
export class OutstandingReceivablesHistory implements IOutstandingReceivablesHistory {
    /** Outstanding receivables or payables calculated for each reporting period. */
    history!: OutstandingReceivableOrPayableList[];

    constructor(data?: IOutstandingReceivablesHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.history = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["history"])) {
                this.history = [] as any;
                for (let item of _data["history"])
                    this.history!.push(OutstandingReceivableOrPayableList.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OutstandingReceivablesHistory {
        data = typeof data === 'object' ? data : {};
        let result = new OutstandingReceivablesHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.history)) {
            data["history"] = [];
            for (let item of this.history)
                data["history"].push(item.toJSON());
        }
        return data; 
    }

    clone(): OutstandingReceivablesHistory {
        const json = this.toJSON();
        let result = new OutstandingReceivablesHistory();
        result.init(json);
        return result;
    }
}

/** Outstanding Receivables by reporting period. */
export interface IOutstandingReceivablesHistory {
    /** Outstanding receivables or payables calculated for each reporting period. */
    history: OutstandingReceivableOrPayableList[];
}

/** Models a calculated percentage. */
export class PercentageValue implements IPercentageValue {
    errorCode?: CalculationError;
    /** The percentage represented as a number between 0 and 1, but may be null if the percentage is undefined (divide by zero). */
    value?: number | undefined;

    constructor(data?: IPercentageValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorCode = _data["errorCode"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PercentageValue {
        data = typeof data === 'object' ? data : {};
        let result = new PercentageValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorCode"] = this.errorCode;
        data["value"] = this.value;
        return data; 
    }

    clone(): PercentageValue {
        const json = this.toJSON();
        let result = new PercentageValue();
        result.init(json);
        return result;
    }
}

/** Models a calculated percentage. */
export interface IPercentageValue {
    errorCode?: CalculationError;
    /** The percentage represented as a number between 0 and 1, but may be null if the percentage is undefined (divide by zero). */
    value?: number | undefined;
}

/** Models a phone number. */
export class PhoneNumber implements IPhoneNumber {
    /** Specific components of the phone number that have been identified. The set of Components do not necessarily provide a complete representation of the phone number. */
    components!: PhoneNumberComponent[];
    /** A name or description of the contact associated with the phone number. For example, "John Doe" or "Customer Support". */
    contact?: string | undefined;
    /** A set of tags for the phone intended to provide accessory information about it. */
    tags!: PhoneNumberTags[];
    /** A complete representation of the phone number without any implied formatting or validation. */
    value!: string;

    constructor(data?: IPhoneNumber) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.components = [];
            this.tags = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["components"])) {
                this.components = [] as any;
                for (let item of _data["components"])
                    this.components!.push(PhoneNumberComponent.fromJS(item));
            }
            this.contact = _data["contact"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PhoneNumber {
        data = typeof data === 'object' ? data : {};
        let result = new PhoneNumber();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.components)) {
            data["components"] = [];
            for (let item of this.components)
                data["components"].push(item.toJSON());
        }
        data["contact"] = this.contact;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["value"] = this.value;
        return data; 
    }

    clone(): PhoneNumber {
        const json = this.toJSON();
        let result = new PhoneNumber();
        result.init(json);
        return result;
    }
}

/** Models a phone number. */
export interface IPhoneNumber {
    /** Specific components of the phone number that have been identified. The set of Components do not necessarily provide a complete representation of the phone number. */
    components: PhoneNumberComponent[];
    /** A name or description of the contact associated with the phone number. For example, "John Doe" or "Customer Support". */
    contact?: string | undefined;
    /** A set of tags for the phone intended to provide accessory information about it. */
    tags: PhoneNumberTags[];
    /** A complete representation of the phone number without any implied formatting or validation. */
    value: string;
}

/** Models the part of a phone number that has been identified. */
export class PhoneNumberComponent implements IPhoneNumberComponent {
    type!: ComponentOfPhoneNumber;
    /** The value of the part of the phone number that has been identified with no implied formatting. */
    value!: string;

    constructor(data?: IPhoneNumberComponent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PhoneNumberComponent {
        data = typeof data === 'object' ? data : {};
        let result = new PhoneNumberComponent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["value"] = this.value;
        return data; 
    }

    clone(): PhoneNumberComponent {
        const json = this.toJSON();
        let result = new PhoneNumberComponent();
        result.init(json);
        return result;
    }
}

/** Models the part of a phone number that has been identified. */
export interface IPhoneNumberComponent {
    type: ComponentOfPhoneNumber;
    /** The value of the part of the phone number that has been identified with no implied formatting. */
    value: string;
}

/** Defines a set of tags providing additional information about a phone number. |Enum Value|Description| |--|--| |Cellular|The phone number is for a cell phone.| |Landline|The phone number is a land line.| |Fax|The phone number is for fax.| |Pager|The phone number is for a pager.| |Support|The phone number is a customer support number.| |Person|The phone number is associated with a person.| |Organization|The phone number is associated with an organization.| */
export type PhoneNumberTags = "Cellular" | "Landline" | "Fax" | "Pager" | "Support" | "Person" | "Organization";

/** Defines the set of privacy controls that can be applied to imported financial data. |Enum Value|Description| |--|--| |AllPrivacyControls|Redact all potential PII. Equivalent to the combination of all possible options.| |AnonymizeAccountingEntity|The [Accounting Entity](https://developer.strongbox.link/guides.html#tocs_accountingentity) will be anonymized. This includes the company name(s), emails, phone numbers, addresses, identifiers, and contact methods.| |AnonymizeContactLists|All customer, vendor, and employee data will be anonymized.| |RedactCOADescription|Redact the `description` for [accounts](https://developer.strongbox.link/guides.html#tocs_account) in the Chart Of Accounts (free-form field).| |RedactCOAName|Redact the `name` for [accounts](https://developer.strongbox.link/guides.html#tocs_account) in the Chart Of Accounts (free-form field).| |RedactDocNoAndRefNo|Redact doc and ref numbers associated with transactions (free-form field).| |RedactTransactionDimensions|Redact dimension values in the [Transaction List](https://developer.strongbox.link/guides.html#tocs_transactionlist) (free-form field).| |RedactTransactionMemos|Redact memos/narrations attached to transactions (free-form field).| */
export type PrivacyControl = "AllPrivacyControls" | "AnonymizeAccountingEntity" | "AnonymizeContactLists" | "RedactCOADescription" | "RedactCOAName" | "RedactDocNoAndRefNo" | "RedactTransactionDimensions" | "RedactTransactionMemos";

/** Used to configure the receivables and payables that are collected from the accounting system. */
export class ReceivablesAndPayablesOptions implements IReceivablesAndPayablesOptions {
    reportingPeriod?: ImportReportingPeriod;
    /** A natural number greater than or equal to zero used to specify the total number of months, quarters, or years for which financial data is desired. The month-to-date, quarter-to-date, or year-to-date period is included in this count. For example, setting 'reportingPeriod' to 'FiscalYears' and 'numberOfReportingPeriods' to 3 should be interpreted as '2 full fiscal years and fiscal YTD'. Setting 'numberOfPeriods' to zero disables data collection. */
    numberOfPeriods!: number;

    constructor(data?: IReceivablesAndPayablesOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reportingPeriod = _data["reportingPeriod"];
            this.numberOfPeriods = _data["numberOfPeriods"];
        }
    }

    static fromJS(data: any): ReceivablesAndPayablesOptions {
        data = typeof data === 'object' ? data : {};
        let result = new ReceivablesAndPayablesOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportingPeriod"] = this.reportingPeriod;
        data["numberOfPeriods"] = this.numberOfPeriods;
        return data; 
    }

    clone(): ReceivablesAndPayablesOptions {
        const json = this.toJSON();
        let result = new ReceivablesAndPayablesOptions();
        result.init(json);
        return result;
    }
}

/** Used to configure the receivables and payables that are collected from the accounting system. */
export interface IReceivablesAndPayablesOptions {
    reportingPeriod?: ImportReportingPeriod;
    /** A natural number greater than or equal to zero used to specify the total number of months, quarters, or years for which financial data is desired. The month-to-date, quarter-to-date, or year-to-date period is included in this count. For example, setting 'reportingPeriod' to 'FiscalYears' and 'numberOfReportingPeriods' to 3 should be interpreted as '2 full fiscal years and fiscal YTD'. Setting 'numberOfPeriods' to zero disables data collection. */
    numberOfPeriods: number;
}

/** Models account totals for a specific reporting period. */
export class ReportedAccountTotals implements IReportedAccountTotals {
    /** The first day of the reporting period (inclusive). */
    fromDate!: string;
    /** The last day for the reporting period (inclusive). */
    toDate!: string;
    /** Lists the totals for each account for the given reporting period. */
    totalsByAccount!: AccountSummary[];

    constructor(data?: IReportedAccountTotals) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.totalsByAccount = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fromDate = _data["fromDate"];
            this.toDate = _data["toDate"];
            if (Array.isArray(_data["totalsByAccount"])) {
                this.totalsByAccount = [] as any;
                for (let item of _data["totalsByAccount"])
                    this.totalsByAccount!.push(AccountSummary.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReportedAccountTotals {
        data = typeof data === 'object' ? data : {};
        let result = new ReportedAccountTotals();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fromDate"] = this.fromDate;
        data["toDate"] = this.toDate;
        if (Array.isArray(this.totalsByAccount)) {
            data["totalsByAccount"] = [];
            for (let item of this.totalsByAccount)
                data["totalsByAccount"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ReportedAccountTotals {
        const json = this.toJSON();
        let result = new ReportedAccountTotals();
        result.init(json);
        return result;
    }
}

/** Models account totals for a specific reporting period. */
export interface IReportedAccountTotals {
    /** The first day of the reporting period (inclusive). */
    fromDate: string;
    /** The last day for the reporting period (inclusive). */
    toDate: string;
    /** Lists the totals for each account for the given reporting period. */
    totalsByAccount: AccountSummary[];
}

/** Specifies the time period for which accounting and other financial data is prepared. |Enum Value|Description| |--|--| |Months|The reporting period is monthly (full months only).| |MonthsAndMTD|The reporting period is monthly and includes the month-to-date period.| |FiscalQuarters|The reporting period is quarterly (full quarters only); aligned to the fiscal year for the accounting entity.| |CalendarQuarters|The reporting period is quarterly (full quarters only); aligned to the calendar year.| |CalendarQuartersAndQtd|The reporting period is quarterly (full quarters only) and includes the quarter-to-date period; aligned to the calendar year.| |FiscalQuartersAndQTD|The reporting period is quarterly and includes the quarter-to-date period; aligned to the fiscal year for the accounting entity.| |FiscalYears|The reporting period is annual (full years only); aligned to the fiscal year for the accounting entity.| |FiscalYearsAndYTD|The reporting period is annual and includes the fiscal year-to-date period; aligned to the fiscal year for the accounting entity.| |FiscalYearsAndTTM|The reporting period is annual (full years only) and includes the TTM period; aligned to the fiscal year for the accounting entity.| |InterimYears|An interim year is similar to a YTD period, but is defined as the number of full months completed in the current fiscal year, and the same period for prior fiscal years.<br/>            The periods are typically labelled "6m17" and "6m18", etc.| |Rolling12Months|The reporting period is based on annualized data from rolling 12 month periods.| |CalendarYears|The reporting period is the calendar year (full years only).| |CalendarYearsAndYTD|The reporting period is the calendar year and includes the year-to-date period.| */
export type ReportingPeriod = "Months" | "MonthsAndMTD" | "FiscalQuarters" | "CalendarQuarters" | "CalendarQuartersAndQtd" | "FiscalQuartersAndQTD" | "FiscalYears" | "FiscalYearsAndYTD" | "FiscalYearsAndTTM" | "InterimYears" | "Rolling12Months" | "CalendarYears" | "CalendarYearsAndYTD";

/** Models a reporting period being compared against a baseline period. */
export class ReportingPeriodComparison implements IReportingPeriodComparison {
    /** A label for the reporting periods being compared. For example, "FY19 to FY20". */
    label!: string;
    reportingPeriod!: ReportingPeriodDescriptor;
    baselinePeriod!: ReportingPeriodDescriptor;

    constructor(data?: IReportingPeriodComparison) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.reportingPeriod = new ReportingPeriodDescriptor();
            this.baselinePeriod = new ReportingPeriodDescriptor();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.reportingPeriod = _data["reportingPeriod"] ? ReportingPeriodDescriptor.fromJS(_data["reportingPeriod"]) : new ReportingPeriodDescriptor();
            this.baselinePeriod = _data["baselinePeriod"] ? ReportingPeriodDescriptor.fromJS(_data["baselinePeriod"]) : new ReportingPeriodDescriptor();
        }
    }

    static fromJS(data: any): ReportingPeriodComparison {
        data = typeof data === 'object' ? data : {};
        let result = new ReportingPeriodComparison();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["reportingPeriod"] = this.reportingPeriod ? this.reportingPeriod.toJSON() : <any>undefined;
        data["baselinePeriod"] = this.baselinePeriod ? this.baselinePeriod.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ReportingPeriodComparison {
        const json = this.toJSON();
        let result = new ReportingPeriodComparison();
        result.init(json);
        return result;
    }
}

/** Models a reporting period being compared against a baseline period. */
export interface IReportingPeriodComparison {
    /** A label for the reporting periods being compared. For example, "FY19 to FY20". */
    label: string;
    reportingPeriod: ReportingPeriodDescriptor;
    baselinePeriod: ReportingPeriodDescriptor;
}

/** Describes a reporting period including the start and end dates (inclusive). */
export class ReportingPeriodDescriptor implements IReportingPeriodDescriptor {
    /** A friendly label for the reporting period. For example "FY 2021". */
    label!: string;
    /** The start date of the reporting period for which the financial data was prepared (inclusive). May be null for point-in-time statements such as the Balance Sheet. */
    fromDate!: string;
    /** The end date of the reporting period for which the financial data was prepared (inclusive). */
    toDate?: string;

    constructor(data?: IReportingPeriodDescriptor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.fromDate = _data["fromDate"];
            this.toDate = _data["toDate"];
        }
    }

    static fromJS(data: any): ReportingPeriodDescriptor {
        data = typeof data === 'object' ? data : {};
        let result = new ReportingPeriodDescriptor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["fromDate"] = this.fromDate;
        data["toDate"] = this.toDate;
        return data; 
    }

    clone(): ReportingPeriodDescriptor {
        const json = this.toJSON();
        let result = new ReportingPeriodDescriptor();
        result.init(json);
        return result;
    }
}

/** Describes a reporting period including the start and end dates (inclusive). */
export interface IReportingPeriodDescriptor {
    /** A friendly label for the reporting period. For example "FY 2021". */
    label: string;
    /** The start date of the reporting period for which the financial data was prepared (inclusive). May be null for point-in-time statements such as the Balance Sheet. */
    fromDate: string;
    /** The end date of the reporting period for which the financial data was prepared (inclusive). */
    toDate?: string;
}

/** Specifies styles for line items that can appear in a financial statement. |Enum Value|Description| |--|--| |Account|The line item represents an account from the business's Chart Of Accounts.| |Subtotal|The line item represents a subtotal.| |GrandTotal|The line item represents a grand total.| |SectionHeader|The line item represents a section header.| |SectionFooter|The line item represents a section footer.| */
export type StyleClasses = "Account" | "Subtotal" | "GrandTotal" | "SectionHeader" | "SectionFooter";

/** Models information about a supplemental field available as part of transactional data. */
export class SupplementalFieldDescriptor implements ISupplementalFieldDescriptor {
    /** An identifier for the supplemental field. */
    id!: string;
    dataType!: FieldDataType;
    /** Specifies a user friendly label for the field. */
    label!: string;

    constructor(data?: ISupplementalFieldDescriptor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dataType = _data["dataType"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): SupplementalFieldDescriptor {
        data = typeof data === 'object' ? data : {};
        let result = new SupplementalFieldDescriptor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dataType"] = this.dataType;
        data["label"] = this.label;
        return data; 
    }

    clone(): SupplementalFieldDescriptor {
        const json = this.toJSON();
        let result = new SupplementalFieldDescriptor();
        result.init(json);
        return result;
    }
}

/** Models information about a supplemental field available as part of transactional data. */
export interface ISupplementalFieldDescriptor {
    /** An identifier for the supplemental field. */
    id: string;
    dataType: FieldDataType;
    /** Specifies a user friendly label for the field. */
    label: string;
}

/** Models the value of a supplemental field included with transaction data. */
export class SupplementalFieldValue implements ISupplementalFieldValue {
    /** An identifier for the supplemental field. */
    id!: string;
    /** The value of the supplemental field, represented as a string. Refer to the data type of the field to interpret the value. */
    value?: string | undefined;

    constructor(data?: ISupplementalFieldValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SupplementalFieldValue {
        data = typeof data === 'object' ? data : {};
        let result = new SupplementalFieldValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        return data; 
    }

    clone(): SupplementalFieldValue {
        const json = this.toJSON();
        let result = new SupplementalFieldValue();
        result.init(json);
        return result;
    }
}

/** Models the value of a supplemental field included with transaction data. */
export interface ISupplementalFieldValue {
    /** An identifier for the supplemental field. */
    id: string;
    /** The value of the supplemental field, represented as a string. Refer to the data type of the field to interpret the value. */
    value?: string | undefined;
}

/** Models an accounting transaction. */
export class Transaction implements ITransaction {
    /** The set of account entries that make up the transaction. */
    entries!: TransactionEntry[];
    /** A unique identifier for this transaction within the scope of the Dataset. */
    id!: string;
    /** The date on which the transaction occurred for financial reporting purposes. This date is serialized to a string using the "YYYY-MM-DD" format as defined by ISO 8601-1:2019. */
    reportingDate!: string;
    /** The date on which the transaction was last modified, if known. This date is serialized to a string using the "YYYY-MM-DD" format as defined by ISO 8601-1:2019. */
    lastModifiedDate?: string | undefined;
    /** The date on which the transaction was created, if known. This date is serialized to a string using the "YYYY-MM-DD" format as defined by ISO 8601-1:2019. */
    creationDate?: string | undefined;
    /** The type of transaction as labeled by the source accounting system. May be null or empty. */
    type?: string | undefined;

    constructor(data?: ITransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.entries = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["entries"])) {
                this.entries = [] as any;
                for (let item of _data["entries"])
                    this.entries!.push(TransactionEntry.fromJS(item));
            }
            this.id = _data["id"];
            this.reportingDate = _data["reportingDate"];
            this.lastModifiedDate = _data["lastModifiedDate"];
            this.creationDate = _data["creationDate"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): Transaction {
        data = typeof data === 'object' ? data : {};
        let result = new Transaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.entries)) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["reportingDate"] = this.reportingDate;
        data["lastModifiedDate"] = this.lastModifiedDate;
        data["creationDate"] = this.creationDate;
        data["type"] = this.type;
        return data; 
    }

    clone(): Transaction {
        const json = this.toJSON();
        let result = new Transaction();
        result.init(json);
        return result;
    }
}

/** Models an accounting transaction. */
export interface ITransaction {
    /** The set of account entries that make up the transaction. */
    entries: TransactionEntry[];
    /** A unique identifier for this transaction within the scope of the Dataset. */
    id: string;
    /** The date on which the transaction occurred for financial reporting purposes. This date is serialized to a string using the "YYYY-MM-DD" format as defined by ISO 8601-1:2019. */
    reportingDate: string;
    /** The date on which the transaction was last modified, if known. This date is serialized to a string using the "YYYY-MM-DD" format as defined by ISO 8601-1:2019. */
    lastModifiedDate?: string | undefined;
    /** The date on which the transaction was created, if known. This date is serialized to a string using the "YYYY-MM-DD" format as defined by ISO 8601-1:2019. */
    creationDate?: string | undefined;
    /** The type of transaction as labeled by the source accounting system. May be null or empty. */
    type?: string | undefined;
}

/** Models additional accounting dimensions such as Business Relations, Products/Services, QuickBooks 'Classes', and Xero 'Tracking Categories' that can be associated with transactional data entries. */
export class TransactionDimension implements ITransactionDimension {
    /** An identifier for the transaction dimension. */
    id!: string;
    /** A label for the transaction dimension. For example, 'Department'. */
    label!: string;

    constructor(data?: ITransactionDimension) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): TransactionDimension {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionDimension();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["label"] = this.label;
        return data; 
    }

    clone(): TransactionDimension {
        const json = this.toJSON();
        let result = new TransactionDimension();
        result.init(json);
        return result;
    }
}

/** Models additional accounting dimensions such as Business Relations, Products/Services, QuickBooks 'Classes', and Xero 'Tracking Categories' that can be associated with transactional data entries. */
export interface ITransactionDimension {
    /** An identifier for the transaction dimension. */
    id: string;
    /** A label for the transaction dimension. For example, 'Department'. */
    label: string;
}

/** Models the value of a transaction dimension that was assigned to an individual transactional data entry. */
export class TransactionDimensionTag implements ITransactionDimensionTag {
    /** An identifier for dimension associated with this tag. */
    dimensionId!: string;
    /** An identifier for the dimension tag. */
    id?: string | undefined;
    /** A label for the dimension tag. */
    label?: string | undefined;

    constructor(data?: ITransactionDimensionTag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dimensionId = _data["dimensionId"];
            this.id = _data["id"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): TransactionDimensionTag {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionDimensionTag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dimensionId"] = this.dimensionId;
        data["id"] = this.id;
        data["label"] = this.label;
        return data; 
    }

    clone(): TransactionDimensionTag {
        const json = this.toJSON();
        let result = new TransactionDimensionTag();
        result.init(json);
        return result;
    }
}

/** Models the value of a transaction dimension that was assigned to an individual transactional data entry. */
export interface ITransactionDimensionTag {
    /** An identifier for dimension associated with this tag. */
    dimensionId: string;
    /** An identifier for the dimension tag. */
    id?: string | undefined;
    /** A label for the dimension tag. */
    label?: string | undefined;
}

/** A transaction entry. */
export class TransactionEntry implements ITransactionEntry {
    /** Values for any additional dimensions for the transaction entry that may be available depending on the accounting system and organization. */
    dimensionTags!: TransactionDimensionTag[];
    /** An identifier for the account affected by this transaction entry. */
    accountId!: string;
    entry!: DoubleEntryAmount;
    /** An optional memorandum for the entry. May be null or empty. */
    memo?: string | undefined;
    /** Defines an ordering for the transaction entry and may be used as an identifier that is unique within the scope of the transaction. Please be aware that this does not necessarily correspond to the visual ordering of the entry as it would appear in the accounting system. */
    number!: number;
    /** An optional alpha-numeric number assigned to the entry by the user or accounting system to the transaction entry. This field is primarily used to identify/find the transaction in the accounting system where searching by transaction id may not be convenient. */
    docNo?: string | undefined;
    /** A secondary alpha-numeric number assigned to the entry by the user or accounting system to the transaction entry. This field is primarily used to identify/find the transaction in the accounting system where searching by transaction id may not be convenient. */
    refNo?: string | undefined;
    /** Additional data fields associated with the transaction entry. */
    supplementalFieldValues!: SupplementalFieldValue[];

    constructor(data?: ITransactionEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.dimensionTags = [];
            this.entry = new DoubleEntryAmount();
            this.supplementalFieldValues = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["dimensionTags"])) {
                this.dimensionTags = [] as any;
                for (let item of _data["dimensionTags"])
                    this.dimensionTags!.push(TransactionDimensionTag.fromJS(item));
            }
            this.accountId = _data["accountId"];
            this.entry = _data["entry"] ? DoubleEntryAmount.fromJS(_data["entry"]) : new DoubleEntryAmount();
            this.memo = _data["memo"];
            this.number = _data["number"];
            this.docNo = _data["docNo"];
            this.refNo = _data["refNo"];
            if (Array.isArray(_data["supplementalFieldValues"])) {
                this.supplementalFieldValues = [] as any;
                for (let item of _data["supplementalFieldValues"])
                    this.supplementalFieldValues!.push(SupplementalFieldValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransactionEntry {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.dimensionTags)) {
            data["dimensionTags"] = [];
            for (let item of this.dimensionTags)
                data["dimensionTags"].push(item.toJSON());
        }
        data["accountId"] = this.accountId;
        data["entry"] = this.entry ? this.entry.toJSON() : <any>undefined;
        data["memo"] = this.memo;
        data["number"] = this.number;
        data["docNo"] = this.docNo;
        data["refNo"] = this.refNo;
        if (Array.isArray(this.supplementalFieldValues)) {
            data["supplementalFieldValues"] = [];
            for (let item of this.supplementalFieldValues)
                data["supplementalFieldValues"].push(item.toJSON());
        }
        return data; 
    }

    clone(): TransactionEntry {
        const json = this.toJSON();
        let result = new TransactionEntry();
        result.init(json);
        return result;
    }
}

/** A transaction entry. */
export interface ITransactionEntry {
    /** Values for any additional dimensions for the transaction entry that may be available depending on the accounting system and organization. */
    dimensionTags: TransactionDimensionTag[];
    /** An identifier for the account affected by this transaction entry. */
    accountId: string;
    entry: DoubleEntryAmount;
    /** An optional memorandum for the entry. May be null or empty. */
    memo?: string | undefined;
    /** Defines an ordering for the transaction entry and may be used as an identifier that is unique within the scope of the transaction. Please be aware that this does not necessarily correspond to the visual ordering of the entry as it would appear in the accounting system. */
    number: number;
    /** An optional alpha-numeric number assigned to the entry by the user or accounting system to the transaction entry. This field is primarily used to identify/find the transaction in the accounting system where searching by transaction id may not be convenient. */
    docNo?: string | undefined;
    /** A secondary alpha-numeric number assigned to the entry by the user or accounting system to the transaction entry. This field is primarily used to identify/find the transaction in the accounting system where searching by transaction id may not be convenient. */
    refNo?: string | undefined;
    /** Additional data fields associated with the transaction entry. */
    supplementalFieldValues: SupplementalFieldValue[];
}

/** Used to configure the transactional data that is collected from the accounting system. */
export class TransactionImportOptions implements ITransactionImportOptions {
    basisOfAccountingPreference?: BasisOfAccountingPreference;
    reportingPeriod?: ImportReportingPeriod;
    /** A natural number greater than or equal to zero used to specify the total number of months, quarters, or years for which financial data is desired. The month-to-date, quarter-to-date, or year-to-date period is included in this count. For example, setting 'reportingPeriod' to 'FiscalYears' and 'numberOfReportingPeriods' to 3 should be interpreted as '2 full fiscal years and fiscal YTD'. Setting 'numberOfPeriods' to zero disables data collection. */
    numberOfPeriods!: number;

    constructor(data?: ITransactionImportOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.basisOfAccountingPreference = _data["basisOfAccountingPreference"];
            this.reportingPeriod = _data["reportingPeriod"];
            this.numberOfPeriods = _data["numberOfPeriods"];
        }
    }

    static fromJS(data: any): TransactionImportOptions {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionImportOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["basisOfAccountingPreference"] = this.basisOfAccountingPreference;
        data["reportingPeriod"] = this.reportingPeriod;
        data["numberOfPeriods"] = this.numberOfPeriods;
        return data; 
    }

    clone(): TransactionImportOptions {
        const json = this.toJSON();
        let result = new TransactionImportOptions();
        result.init(json);
        return result;
    }
}

/** Used to configure the transactional data that is collected from the accounting system. */
export interface ITransactionImportOptions {
    basisOfAccountingPreference?: BasisOfAccountingPreference;
    reportingPeriod?: ImportReportingPeriod;
    /** A natural number greater than or equal to zero used to specify the total number of months, quarters, or years for which financial data is desired. The month-to-date, quarter-to-date, or year-to-date period is included in this count. For example, setting 'reportingPeriod' to 'FiscalYears' and 'numberOfReportingPeriods' to 3 should be interpreted as '2 full fiscal years and fiscal YTD'. Setting 'numberOfPeriods' to zero disables data collection. */
    numberOfPeriods: number;
}

/** Models the complete set of accounting transactions for a given time period. */
export class TransactionList implements ITransactionList {
    /** Defines the set of supplemental data fields included with the transactional data, if any. */
    supplementalFields!: SupplementalFieldDescriptor[];
    /** A list of the dimensions that are available as part of the transactional data. The set of dimensions may vary by accounting system and even by each organization.
<br></br>
Examples of dimensions are Business Relations, Products/Services, QuickBooks 'Classes', and Xero 'Tracking Categories'. */
    dimensions!: TransactionDimension[];
    /** Transactions on or after this date are included. */
    fromDate!: string;
    /** Transactions on or before this date are included. */
    toDate!: string;
    /** The complete set of accounting transactions for the specified time period. */
    transactions!: Transaction[];

    constructor(data?: ITransactionList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.supplementalFields = [];
            this.dimensions = [];
            this.transactions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["supplementalFields"])) {
                this.supplementalFields = [] as any;
                for (let item of _data["supplementalFields"])
                    this.supplementalFields!.push(SupplementalFieldDescriptor.fromJS(item));
            }
            if (Array.isArray(_data["dimensions"])) {
                this.dimensions = [] as any;
                for (let item of _data["dimensions"])
                    this.dimensions!.push(TransactionDimension.fromJS(item));
            }
            this.fromDate = _data["fromDate"];
            this.toDate = _data["toDate"];
            if (Array.isArray(_data["transactions"])) {
                this.transactions = [] as any;
                for (let item of _data["transactions"])
                    this.transactions!.push(Transaction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransactionList {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.supplementalFields)) {
            data["supplementalFields"] = [];
            for (let item of this.supplementalFields)
                data["supplementalFields"].push(item.toJSON());
        }
        if (Array.isArray(this.dimensions)) {
            data["dimensions"] = [];
            for (let item of this.dimensions)
                data["dimensions"].push(item.toJSON());
        }
        data["fromDate"] = this.fromDate;
        data["toDate"] = this.toDate;
        if (Array.isArray(this.transactions)) {
            data["transactions"] = [];
            for (let item of this.transactions)
                data["transactions"].push(item.toJSON());
        }
        return data; 
    }

    clone(): TransactionList {
        const json = this.toJSON();
        let result = new TransactionList();
        result.init(json);
        return result;
    }
}

/** Models the complete set of accounting transactions for a given time period. */
export interface ITransactionList {
    /** Defines the set of supplemental data fields included with the transactional data, if any. */
    supplementalFields: SupplementalFieldDescriptor[];
    /** A list of the dimensions that are available as part of the transactional data. The set of dimensions may vary by accounting system and even by each organization.
<br></br>
Examples of dimensions are Business Relations, Products/Services, QuickBooks 'Classes', and Xero 'Tracking Categories'. */
    dimensions: TransactionDimension[];
    /** Transactions on or after this date are included. */
    fromDate: string;
    /** Transactions on or before this date are included. */
    toDate: string;
    /** The complete set of accounting transactions for the specified time period. */
    transactions: Transaction[];
}

/** Models a Vertical Analysis */
export class VerticalAnalysis implements IVerticalAnalysis {
    /** Information about the set of reporting periods included in the vertical analysis. */
    reportingPeriods!: ReportingPeriodDescriptor[];
    incomeStatement!: IncomeStatementVerticalAnalysis;
    balanceSheet!: BalanceSheetVerticalAnalysis;

    constructor(data?: IVerticalAnalysis) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.reportingPeriods = [];
            this.incomeStatement = new IncomeStatementVerticalAnalysis();
            this.balanceSheet = new BalanceSheetVerticalAnalysis();
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["reportingPeriods"])) {
                this.reportingPeriods = [] as any;
                for (let item of _data["reportingPeriods"])
                    this.reportingPeriods!.push(ReportingPeriodDescriptor.fromJS(item));
            }
            this.incomeStatement = _data["incomeStatement"] ? IncomeStatementVerticalAnalysis.fromJS(_data["incomeStatement"]) : new IncomeStatementVerticalAnalysis();
            this.balanceSheet = _data["balanceSheet"] ? BalanceSheetVerticalAnalysis.fromJS(_data["balanceSheet"]) : new BalanceSheetVerticalAnalysis();
        }
    }

    static fromJS(data: any): VerticalAnalysis {
        data = typeof data === 'object' ? data : {};
        let result = new VerticalAnalysis();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.reportingPeriods)) {
            data["reportingPeriods"] = [];
            for (let item of this.reportingPeriods)
                data["reportingPeriods"].push(item.toJSON());
        }
        data["incomeStatement"] = this.incomeStatement ? this.incomeStatement.toJSON() : <any>undefined;
        data["balanceSheet"] = this.balanceSheet ? this.balanceSheet.toJSON() : <any>undefined;
        return data; 
    }

    clone(): VerticalAnalysis {
        const json = this.toJSON();
        let result = new VerticalAnalysis();
        result.init(json);
        return result;
    }
}

/** Models a Vertical Analysis */
export interface IVerticalAnalysis {
    /** Information about the set of reporting periods included in the vertical analysis. */
    reportingPeriods: ReportingPeriodDescriptor[];
    incomeStatement: IncomeStatementVerticalAnalysis;
    balanceSheet: BalanceSheetVerticalAnalysis;
}

/** Comparative data representing a Vertical Analysis of a single line item appearing on a financial statement. */
export class VerticalAnalysisLineItem implements IVerticalAnalysisLineItem {
    /** An identifier for the line item. */
    id!: string;
    accountRef?: AccountReference;
    /** The line item caption, which is label for the line item as it would appear on the statement. */
    caption!: string;
    lineItemType!: LineItemType;
    /** An identifier for the line item to which this line item is being compared, if applicable. */
    baselineFigureId?: string | undefined;
    /** The results of comparing this line item to the comparand line item, by reporting period. */
    comparativeData!: VerticalComparison[];
    /** Each line item may contain a set of subtotal lines. */
    subtotals!: VerticalAnalysisLineItem[];

    constructor(data?: IVerticalAnalysisLineItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.comparativeData = [];
            this.subtotals = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.accountRef = _data["accountRef"] ? AccountReference.fromJS(_data["accountRef"]) : <any>undefined;
            this.caption = _data["caption"];
            this.lineItemType = _data["lineItemType"];
            this.baselineFigureId = _data["baselineFigureId"];
            if (Array.isArray(_data["comparativeData"])) {
                this.comparativeData = [] as any;
                for (let item of _data["comparativeData"])
                    this.comparativeData!.push(VerticalComparison.fromJS(item));
            }
            if (Array.isArray(_data["subtotals"])) {
                this.subtotals = [] as any;
                for (let item of _data["subtotals"])
                    this.subtotals!.push(VerticalAnalysisLineItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VerticalAnalysisLineItem {
        data = typeof data === 'object' ? data : {};
        let result = new VerticalAnalysisLineItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["accountRef"] = this.accountRef ? this.accountRef.toJSON() : <any>undefined;
        data["caption"] = this.caption;
        data["lineItemType"] = this.lineItemType;
        data["baselineFigureId"] = this.baselineFigureId;
        if (Array.isArray(this.comparativeData)) {
            data["comparativeData"] = [];
            for (let item of this.comparativeData)
                data["comparativeData"].push(item.toJSON());
        }
        if (Array.isArray(this.subtotals)) {
            data["subtotals"] = [];
            for (let item of this.subtotals)
                data["subtotals"].push(item.toJSON());
        }
        return data; 
    }

    clone(): VerticalAnalysisLineItem {
        const json = this.toJSON();
        let result = new VerticalAnalysisLineItem();
        result.init(json);
        return result;
    }
}

/** Comparative data representing a Vertical Analysis of a single line item appearing on a financial statement. */
export interface IVerticalAnalysisLineItem {
    /** An identifier for the line item. */
    id: string;
    accountRef?: AccountReference;
    /** The line item caption, which is label for the line item as it would appear on the statement. */
    caption: string;
    lineItemType: LineItemType;
    /** An identifier for the line item to which this line item is being compared, if applicable. */
    baselineFigureId?: string | undefined;
    /** The results of comparing this line item to the comparand line item, by reporting period. */
    comparativeData: VerticalComparison[];
    /** Each line item may contain a set of subtotal lines. */
    subtotals: VerticalAnalysisLineItem[];
}

/** Models a comparison between two values calculated as part of a vertical analysis. */
export class VerticalComparison implements IVerticalComparison {
    /** The value of the metric being compared to the `comparandValue`. */
    value!: number;
    /** The `value` is compared to the `comparandValue`. */
    comparandValue!: number;
    percentageRatio!: PercentageValue;

    constructor(data?: IVerticalComparison) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.percentageRatio = new PercentageValue();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.comparandValue = _data["comparandValue"];
            this.percentageRatio = _data["percentageRatio"] ? PercentageValue.fromJS(_data["percentageRatio"]) : new PercentageValue();
        }
    }

    static fromJS(data: any): VerticalComparison {
        data = typeof data === 'object' ? data : {};
        let result = new VerticalComparison();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["comparandValue"] = this.comparandValue;
        data["percentageRatio"] = this.percentageRatio ? this.percentageRatio.toJSON() : <any>undefined;
        return data; 
    }

    clone(): VerticalComparison {
        const json = this.toJSON();
        let result = new VerticalComparison();
        result.init(json);
        return result;
    }
}

/** Models a comparison between two values calculated as part of a vertical analysis. */
export interface IVerticalComparison {
    /** The value of the metric being compared to the `comparandValue`. */
    value: number;
    /** The `value` is compared to the `comparandValue`. */
    comparandValue: number;
    percentageRatio: PercentageValue;
}

/** Models a Webhook Endpoint that will be invoked whenever a configured event occurs within the Strongbox Platform. */
export class WebhookEndpoint implements IWebhookEndpoint {
    /** The time at which the webhook was created. */
    creationTime!: string;
    /** The set of events for which the webhook will be invoked. */
    eventTypes!: string[];
    /** An identifier for the Webhook Endpoint. */
    id!: string;
    /** A secret used in combination with HMAC SHA256 to sign requests that are sent to the webhook endpoint. */
    sharedSecret!: string;
    /** The absolute URL to the endpoint that will be called. The URL must use the `https` scheme. */
    url!: string;

    constructor(data?: IWebhookEndpoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.eventTypes = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.creationTime = _data["creationTime"];
            if (Array.isArray(_data["eventTypes"])) {
                this.eventTypes = [] as any;
                for (let item of _data["eventTypes"])
                    this.eventTypes!.push(item);
            }
            this.id = _data["id"];
            this.sharedSecret = _data["sharedSecret"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): WebhookEndpoint {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookEndpoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creationTime"] = this.creationTime;
        if (Array.isArray(this.eventTypes)) {
            data["eventTypes"] = [];
            for (let item of this.eventTypes)
                data["eventTypes"].push(item);
        }
        data["id"] = this.id;
        data["sharedSecret"] = this.sharedSecret;
        data["url"] = this.url;
        return data; 
    }

    clone(): WebhookEndpoint {
        const json = this.toJSON();
        let result = new WebhookEndpoint();
        result.init(json);
        return result;
    }
}

/** Models a Webhook Endpoint that will be invoked whenever a configured event occurs within the Strongbox Platform. */
export interface IWebhookEndpoint {
    /** The time at which the webhook was created. */
    creationTime: string;
    /** The set of events for which the webhook will be invoked. */
    eventTypes: string[];
    /** An identifier for the Webhook Endpoint. */
    id: string;
    /** A secret used in combination with HMAC SHA256 to sign requests that are sent to the webhook endpoint. */
    sharedSecret: string;
    /** The absolute URL to the endpoint that will be called. The URL must use the `https` scheme. */
    url: string;
}

/** Models a list of Webhook Endpoints. */
export class WebhookEndpointList implements IWebhookEndpointList {
    /** The list of Webhook Endpoints. */
    webhookEndpoints!: WebhookEndpoint[];

    constructor(data?: IWebhookEndpointList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.webhookEndpoints = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["webhookEndpoints"])) {
                this.webhookEndpoints = [] as any;
                for (let item of _data["webhookEndpoints"])
                    this.webhookEndpoints!.push(WebhookEndpoint.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WebhookEndpointList {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookEndpointList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.webhookEndpoints)) {
            data["webhookEndpoints"] = [];
            for (let item of this.webhookEndpoints)
                data["webhookEndpoints"].push(item.toJSON());
        }
        return data; 
    }

    clone(): WebhookEndpointList {
        const json = this.toJSON();
        let result = new WebhookEndpointList();
        result.init(json);
        return result;
    }
}

/** Models a list of Webhook Endpoints. */
export interface IWebhookEndpointList {
    /** The list of Webhook Endpoints. */
    webhookEndpoints: WebhookEndpoint[];
}

/** Models a webhook endpoint that will be invoked whenever a configured event occurs within the Strongbox Platform. */
export class WebhookEndpointParameters implements IWebhookEndpointParameters {
    /** The set of events for which the webhook will be invoked. */
    events!: string[];
    /** The absolute URL to the endpoint that will be called. The URL must use the `https` scheme. */
    url!: string;

    constructor(data?: IWebhookEndpointParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.events = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["events"])) {
                this.events = [] as any;
                for (let item of _data["events"])
                    this.events!.push(item);
            }
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): WebhookEndpointParameters {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookEndpointParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.events)) {
            data["events"] = [];
            for (let item of this.events)
                data["events"].push(item);
        }
        data["url"] = this.url;
        return data; 
    }

    clone(): WebhookEndpointParameters {
        const json = this.toJSON();
        let result = new WebhookEndpointParameters();
        result.init(json);
        return result;
    }
}

/** Models a webhook endpoint that will be invoked whenever a configured event occurs within the Strongbox Platform. */
export interface IWebhookEndpointParameters {
    /** The set of events for which the webhook will be invoked. */
    events: string[];
    /** The absolute URL to the endpoint that will be called. The URL must use the `https` scheme. */
    url: string;
}

/** Models information about a website. */
export class Website implements IWebsite {
    /** The URL of the website without any implied formatting or validation. */
    url!: string;

    constructor(data?: IWebsite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): Website {
        data = typeof data === 'object' ? data : {};
        let result = new Website();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        return data; 
    }

    clone(): Website {
        const json = this.toJSON();
        let result = new Website();
        result.init(json);
        return result;
    }
}

/** Models information about a website. */
export interface IWebsite {
    /** The URL of the website without any implied formatting or validation. */
    url: string;
}

/** Represents the end of a fiscal, tax, or other year used for reporting. */
export class YearEnd implements IYearEnd {
    /** A number between 1-12 representing the month considered to be the end of the year for reporting purposes. */
    month!: number;

    constructor(data?: IYearEnd) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.month = _data["month"];
        }
    }

    static fromJS(data: any): YearEnd {
        data = typeof data === 'object' ? data : {};
        let result = new YearEnd();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["month"] = this.month;
        return data; 
    }

    clone(): YearEnd {
        const json = this.toJSON();
        let result = new YearEnd();
        result.init(json);
        return result;
    }
}

/** Represents the end of a fiscal, tax, or other year used for reporting. */
export interface IYearEnd {
    /** A number between 1-12 representing the month considered to be the end of the year for reporting purposes. */
    month: number;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}